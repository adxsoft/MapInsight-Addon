<map version="freeplane 1.5.9">
<!--To view this file, download free mind mapping software Freeplane from http://freeplane.sourceforge.net -->
<attribute_registry SHOW_ATTRIBUTES="hide"/>
<node TEXT="MapInsight" FOLDED="false" ID="ID_1723255651" CREATED="1283093380553" MODIFIED="1513920903319" LINK="https://github.com/adxsoft/MapInsight.addon" BACKGROUND_COLOR="#97c7dc">
<font SIZE="16" BOLD="true" ITALIC="true"/>
<hook NAME="MapStyle" zoom="1.5">
    <properties show_icon_for_attributes="true" fit_to_viewport="false;" show_note_icons="true"/>

<map_styles>
<stylenode LOCALIZED_TEXT="styles.root_node" STYLE="oval" UNIFORM_SHAPE="true" VGAP_QUANTITY="24.0 pt">
<font SIZE="24"/>
<stylenode LOCALIZED_TEXT="styles.predefined" POSITION="right" STYLE="bubble">
<stylenode LOCALIZED_TEXT="default" MAX_WIDTH="600.0 px" COLOR="#000000" STYLE="as_parent">
<font NAME="SansSerif" SIZE="10" BOLD="false" ITALIC="false"/>
</stylenode>
<stylenode LOCALIZED_TEXT="defaultstyle.details"/>
<stylenode LOCALIZED_TEXT="defaultstyle.attributes">
<font SIZE="9"/>
</stylenode>
<stylenode LOCALIZED_TEXT="defaultstyle.note"/>
<stylenode LOCALIZED_TEXT="defaultstyle.floating">
<edge STYLE="hide_edge"/>
<cloud COLOR="#f0f0f0" SHAPE="ROUND_RECT"/>
</stylenode>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.user-defined" POSITION="right" STYLE="bubble">
<stylenode LOCALIZED_TEXT="styles.topic" COLOR="#18898b" STYLE="fork">
<font NAME="Liberation Sans" SIZE="10" BOLD="true"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.subtopic" COLOR="#cc3300" STYLE="fork">
<font NAME="Liberation Sans" SIZE="10" BOLD="true"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.subsubtopic" COLOR="#669900">
<font NAME="Liberation Sans" SIZE="10" BOLD="true"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.important">
<icon BUILTIN="yes"/>
</stylenode>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.AutomaticLayout" POSITION="right" STYLE="bubble">
<stylenode LOCALIZED_TEXT="AutomaticLayout.level.root" COLOR="#000000">
<font SIZE="18"/>
</stylenode>
<stylenode LOCALIZED_TEXT="AutomaticLayout.level,1" COLOR="#0033ff">
<font SIZE="16"/>
</stylenode>
<stylenode LOCALIZED_TEXT="AutomaticLayout.level,2" COLOR="#00b439">
<font SIZE="14"/>
</stylenode>
<stylenode LOCALIZED_TEXT="AutomaticLayout.level,3" COLOR="#990000">
<font SIZE="12"/>
</stylenode>
<stylenode LOCALIZED_TEXT="AutomaticLayout.level,4" COLOR="#111111">
<font SIZE="10"/>
</stylenode>
</stylenode>
</stylenode>
</map_styles>
</hook>
<hook NAME="AutomaticEdgeColor" COUNTER="11" RULE="ON_BRANCH_CREATION"/>
<attribute_layout NAME_WIDTH="99.89999523639702 pt" VALUE_WIDTH="296.9999858379371 pt"/>
<attribute NAME="name" VALUE="MapInsight"/>
<attribute NAME="link" VALUE="https://github.com/adxsoft/MapInsight.addon" OBJECT="java.net.URI|https://github.com/adxsoft/MapInsight.addon"/>
<attribute NAME="version" VALUE="v1.1"/>
<attribute NAME="author" VALUE="adxsoft (Allan)"/>
<attribute NAME="freeplaneVersionFrom" VALUE="v1.3.5"/>
<attribute NAME="freeplaneVersionTo" VALUE=""/>
<richcontent TYPE="NOTE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      The homepage of this add-on should be set as the link of the root node.
    </p>
    <p>
      The basic properties of this add-on. They can be used in script names and other attributes, e.g. &quot;${name}.groovy&quot;.
    </p>
    <ul>
      <li>
        name: The name of the add-on, normally a technically one (no spaces, no special characters except _.-).
      </li>
      <li>
        author: Author's name(s) and (optionally) email adresses.
      </li>
      <li>
        version: Since it's difficult to protect numbers like 1.0 from Freeplane's number parser it's advised to prepend a 'v' to the number, e.g. 'v1.0'.
      </li>
      <li>
        freeplane-version-from: The oldest compatible Freeplane version. The add-on will not be installed if the Freeplane version is too old.
      </li>
      <li>
        freeplane-version-to: Normally empty: The newest compatible Freeplane version. The add-on will not be installed if the Freeplane version is too new.
      </li>
    </ul>
  </body>
</html>
</richcontent>
<node TEXT="scripts" POSITION="right" ID="ID_1694956411" CREATED="1381771547809" MODIFIED="1385408757667">
<edge COLOR="#00007c"/>
<richcontent TYPE="NOTE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      An add-on may contain multiple scripts. The node text defines the script name (e.g. inserInlineImage.groovy). Its properties have to be configured via attributes:
    </p>
    <p>
      
    </p>
    <p>
      * menuLocation: &lt;locationkey&gt;
    </p>
    <p>
      &#160;&#160;&#160;- Defines where the menu location.
    </p>
    <p>
      &#160;&#160;&#160;-&#160;See mindmapmodemenu.xml for how the menu locations look like.
    </p>
    <p>
      &#160;&#160;&#160;- http://freeplane.bzr.sf.net/bzr/freeplane/freeplane_program/trunk/annotate/head%3A/freeplane/resources/xml/mindmapmodemenu.xml
    </p>
    <p>
      &#160;&#160;&#160;- This attribute is mandatory
    </p>
    <p>
      
    </p>
    <p>
      * menuTitleKey: &lt;key&gt;
    </p>
    <p>
      &#160;&#160;&#160;- The menu item title will be looked up under the translation key &lt;key&gt; - don't forget to define its translation.
    </p>
    <p>
      &#160;&#160;&#160;- This attribute is mandatory
    </p>
    <p>
      
    </p>
    <p>
      * executionMode: &lt;mode&gt;
    </p>
    <p>
      &#160;&#160;&#160;- The execution mode as described in the Freeplane wiki (http://freeplane.sourceforge.net/wiki/index.php/Scripting)
    </p>
    <p>
      &#160;&#160;&#160;- ON_SINGLE_NODE: Execute the script once. The <i>node</i>&#160;variable is set to the selected node.
    </p>
    <p>
      &#160;&#160;&#160;- ON_SELECTED_NODE: Execute the script n times for n selected nodes, once for each node.
    </p>
    <p>
      &#160;&#160;&#160;- ON_SELECTED_NODE_RECURSIVELY: Execute the script on every selected node and recursively on all of its children.
    </p>
    <p>
      &#160;&#160;&#160;- In doubt use ON_SINGLE_NODE.
    </p>
    <p>
      &#160;&#160;&#160;- This attribute is mandatory
    </p>
    <p>
      
    </p>
    <p>
      * keyboardShortcut: &lt;shortcut&gt;
    </p>
    <p>
      &#160;&#160;&#160;- Optional: keyboard combination / accelerator for this script, e.g. control alt I
    </p>
    <p>
      &#160;&#160;&#160;- Use lowercase letters for modifiers and uppercase for letters. Use no + signs.
    </p>
    <p>
      &#160;&#160;&#160;- The available key names are listed at http://download.oracle.com/javase/1.4.2/docs/api/java/awt/event/KeyEvent.html#VK_0
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;In the list only entries with a 'VK_' prefix count. Omit the prefix in the shortcut definition.
    </p>
    <p>
      
    </p>
    <p>
      * Permissions&#160;that the script(s) require, each either false or true:
    </p>
    <p>
      &#160;&#160;&#160;- execute_scripts_without_asking
    </p>
    <p>
      &#160;&#160;&#160;- execute_scripts_without_file_restriction: permission to read files
    </p>
    <p>
      &#160;&#160;&#160;- execute_scripts_without_write_restriction: permission to create/change/delete files
    </p>
    <p>
      &#160;&#160;&#160;- execute_scripts_without_exec_restriction: permission to execute other programs
    </p>
    <p>
      &#160;&#160;&#160;- execute_scripts_without_network_restriction: permission to access the network
    </p>
    <p>
      &#160;&#160;Notes:
    </p>
    <p>
      &#160;&#160;- The set of permissions is fixed.
    </p>
    <p>
      &#160;&#160;- Don't change the attribute names, don't omit one.
    </p>
    <p>
      &#160;&#160;- Set the values either to true or to false
    </p>
    <p>
      &#160;&#160;- In any case set execute_scripts_without_asking to true unless you want to annoy users.
    </p>
  </body>
</html>
</richcontent>
<node TEXT="MapInsight.groovy" FOLDED="true" ID="ID_1884275784" CREATED="1375422555989" MODIFIED="1520820521172">
<attribute_layout NAME_WIDTH="258.2999876832968 pt" VALUE_WIDTH="285.2999863958365 pt"/>
<attribute NAME="menuTitleKey" VALUE="MapInsight"/>
<attribute NAME="menuLocation" VALUE="/menu_bar/view/MapInsight"/>
<attribute NAME="executionMode" VALUE="on_single_node"/>
<attribute NAME="keyboardShortcut" VALUE=""/>
<attribute NAME="execute_scripts_without_asking" VALUE="true"/>
<attribute NAME="execute_scripts_without_file_restriction" VALUE="true"/>
<attribute NAME="execute_scripts_without_write_restriction" VALUE="true"/>
<attribute NAME="execute_scripts_without_exec_restriction" VALUE="true"/>
<attribute NAME="execute_scripts_without_network_restriction" VALUE="false"/>
<node TEXT="scriptVersion=&apos;MapInsight v1.1&apos;&#xa;&#xa;helptext1=&quot;&quot;&quot;&#xa;$scriptVersion&#xa;28th July 2017&#xa;&#xa;1. WALKING AROUND NODES&#xa;This script creates a free standing resizable window that allows you to &apos;walk&apos; around&#xa;the nodes in a map.&#xa;&#xa;When the script is run the currently selected node in the map is displayed along with its related nodes&#xa;ie. parent, children, connections in and out.&#xa;&#xa;The user can double click any of the related nodes and it will be selected and become the currently selected node&#xa;&#xa;Hovering over any related nodes shows its note and detail text if present.&#xa;&#xa;To see the Note and details of the currently selected node use the View Menu and select Node Details&#xa;&#xa;To see recent nodes visited see the History menu item&#xa;&quot;&quot;&quot;&#xa;&#xa;helptext2=&quot;&quot;&quot;&#xa;&#xa;2. FINDING ASSOCIATED NODES&#xa;&#xa;The script shows a sortable list of any possible related nodes (candidate nodes) by using &apos;proper&apos;&#xa;words&#xa;(a) from the selected node&apos;s core text&#xa;(b) optionally from the node&apos;s note text&#xa;(c) optionally from the node&apos;s detail text&#xa;(d) and/or words entered by the user (separated by commas) or you can&#xa;    specify a search phrase which is any string inside double quotes&#xa;(e) or a regular expression which is any string inside forward slashes&#xa;    eg /M.*h/ would find the text March, Macbeth. Moth&#xa;&#xa;For example if the selected node had the word &apos;London&apos;&#xa;then any other nodes in map with the word &apos;London&apos; in them would show as a possible connections.&#xa;&#xa;(Proper word means a word is not a noise or stop word such as and, or, if etc.&#xa; This script has English stop words - can alter by changing &apos;stopWords&apos; table in script)&#xa;&#xa;If a candidate node is selected it will turn blue.&#xa;&#xa;Once selected you can view the node in the map without selecting it (locate button) or&#xa;select the node (Go To button) and Map Insight will &apos;walk&apos; to that node.&#xa;&#xa;If a candidate node is right clicked then you can choose to add a connector between the main node and&#xa;the selected candidate node. The connector is created with the middle label being the word that links&#xa;the main and candidate node (eg &apos;london&apos; in the example above).&#xa;&#xa;If you wish to automatically create a connector for ALL the candidates then&#xa;press the &quot;Connect All&quot; button. You can reverse this by clicking the &quot;Undo Connect ALL&quot; button.&#xa;&quot;&quot;&quot;&#xa;&#xa;helptext3=&quot;&quot;&quot;&#xa;3. MANAGING CONNECTORS&#xa;&#xa;Shows all the connectors in a sortable list and allows you to remove them or change the label if required.&#xa;&#xa;This is useful when a map has so many connectors that they are difficult to see in the map&#xa;&#xa;First select the base node to see the connectors belonging to it and its sub nodes.&#xa;Selecting the root node will view all connectors in the map.&#xa;&#xa;Choose &apos;Connectors Manager&apos; in the View menu&#xa;&#xa;All connectors will be shown with the source node, target node and middle label. (To avoid label confusion&#xa;I decided to just use middle labels).&#xa;&#xa;Clicking on a connector will highlight the connector in BLUE in the list and BLUE in the map.&#xa;&#xa;You can remove the connector by clicking the &apos;Remove Connector&apos; button&#xa;&#xa;You can change the connectors middle label by clicking the &apos;Edit Label&apos;&#xa;&#xa;4. VIEWING CONNECTORS&#xa;&#xa;The sub menu in the View menu lets you view specific connectors&#xa;&#xa;&apos;Show Current Node Connectors&apos; will display only connectors to and from the current node in the map. All other&#xa;connectors will be hidden&#xa;&#xa;&apos;Show Connectors for a label&apos; will display only connectors with a specific label in the map. All other&#xa;connectors will be hidden&#xa;&#xa;&apos;Hide all Connectors&apos; will hide all connectors in the map (useful in crowded maps)&#xa;&#xa;&apos;Unhide all Connectors&apos; will show all connectors in the map&#xa;&#xa;&quot;&quot;&quot;&#xa;&#xa;versionhistory=&quot;&quot;&quot;&#xa;Version History&#xa;v1.0 First Version&#xa;v1.1 Added following new features thanks to forum members feedback&#xa;1. &apos;Refresh current view&apos; in the Actions menu. Updates the current node details which is handy when underlying map has changed&#xa;2. New button &apos;Save As Map&apos; on &apos;Possible Connections&apos; window will save the source node and all suggested nodes together&#xa;   with the connectors into a new map&#xa;3. Connector Candidates Options windows now caters for regular expressions&#xa;4. View, Connectors has new menu item &apos;Show Current Node Connectors&apos; which will display only the connectors for the&#xa;   current node and hide all other connectors. &apos;Unhide All Connectors&apos; will restore view of all connectors&#xa;5. View, Connectors has new menu item &apos;Show Connectors for a label&apos; which will display only the connectors with a&#xa;   middle label that contains the label text and hide all other connectors. &apos;Unhide All Connectors&apos; will restore view of all connectors&#xa;6. Allows multiline labels when adding connectors&#xa;7. Bug fixes (as per https://sourceforge.net/p/freeplane/discussion/758437/thread/a49efba6/)&#xa;&quot;&quot;&quot;&#xa;&#xa;installation=&quot;&quot;&quot;&#xa;Installation&#xa;1. Open the User Directory in Freeplane (Tools/Open User directory)&#xa;2. Open the scripts folder&#xa;3. Save this script as &apos;Map Insight v0.1.groovy&apos; in the scripts folder&#xa;4. Restart Freeplane&#xa;&#xa;To Use Script&#xa;1. Select an existing node&#xa;2. In Freeplane &apos;Tools&apos; menu select &apos;Scripts&apos;&#xa;3. Choose the script &apos;Map_Insight_V1_0&apos;&#xa;&quot;&quot;&quot;&#xa;&#xa;import javax.swing.*&#xa;import java.awt.*&#xa;import groovy.swing.SwingBuilder&#xa;import javax.swing.table.*&#xa;import java.awt.event.*&#xa;import java.text.SimpleDateFormat&#xa;import java.util.concurrent.TimeUnit&#xa;&#xa;//*********************************************&#xa;//         Global Variables&#xa;//*********************************************&#xa;&#xa;newNode=null                        // refers to the node that Map Insight is focussed on&#xa;// (central white node in the Map Insight window&#xa;&#xa;def recenthistoryDisplayed=false        // stops recent history being displayed twice&#xa;&#xa;def selectedCandidateNode=null          // refers to a node that may be a connector candidate&#xa;&#xa;def selectedConnectortablerow=null      // refers to a connector table row that is currently selected in the Connectors window&#xa;&#xa;def selectedconnectorobject=null        // refers to the connector object that is currently selected in the Connectors window&#xa;&#xa;def currentconnectorobjects=[]          // buffr used to store all connectors for cut and paste&#xa;&#xa;//*********************************************&#xa;//         Global Functions&#xa;//*********************************************&#xa;&#xa;// These global function closures are added to the main groovy script object (Object.metaClass)&#xa;// so they can be used globally through the script&#xa;Object.metaClass.msg = {text -&gt; msg(text)}&#xa;Object.metaClass.statusBarMsg = {msg -&gt; statusBarMsg(msg)}&#xa;Object.metaClass.getNodeFromMapSelection = {-&gt; getNodeFromMapSelection()}&#xa;Object.metaClass.getNodeByID = {nodeID -&gt; getNodeByID(nodeID)}&#xa;Object.metaClass.findNodeByID = {nodeID -&gt; findNodeByID(nodeID)}&#xa;Object.metaClass.selectNodeByID = {nodeID -&gt; selectNodeByID(nodeID)}&#xa;Object.metaClass.formatForSwingDisplay = {nodetype,text,note,details -&gt; formatForSwingDisplay(nodetype,text,note,details)}&#xa;Object.metaClass.removeHtmlTags = {text -&gt; removeHtmlTags(text)}&#xa;Object.metaClass.removeHtmlTags = {-&gt; setAllConnectorsToDefaultColor()}&#xa;Object.metaClass.showConnectorsForCurrentNode = {-&gt; showConnectorsForCurrentNode()}&#xa;Object.metaClass.hideAllConnectors = {-&gt; hideAllConnectors()}&#xa;Object.metaClass.unhideAllConnectors = {-&gt; unhideAllConnectors()}&#xa;Object.metaClass.formatNodeTextForCell = {nodetext -&gt;formatNodeTextForCell(nodetext)}&#xa;Object.metaClass.removeAllConnectors = {-&gt;removeAllConnectors()}&#xa;&#xa;//-----------------------&#xa;// == GLOBAL FUNCTION: == display text as Freeplane information message&#xa;def msg(text) {&#xa;    ui.informationMessage(text)&#xa;}&#xa;&#xa;&#xa;//-----------------------&#xa;// == GLOBAL FUNCTION: == display text on status bar&#xa;def statusBarMsg(msg) {&#xa;    c.statusInfo=msg&#xa;}&#xa;&#xa;//-----------------------&#xa;// == GLOBAL FUNCTION: == get node object for currently selected node&#xa;def getNodeFromMapSelection() {&#xa;    def theNode=null&#xa;    c.selected.each{&#xa;        theNode=it&#xa;    }&#xa;    return theNode&#xa;}&#xa;&#xa;//-----------------------&#xa;// == GLOBAL FUNCTION: == get node object for specific node ID&#xa;def getNodeByID(nodeID) {&#xa;    def theNode=null&#xa;    c.find{it.nodeID==nodeID}.each{&#xa;        theNode=it&#xa;    }&#xa;    return theNode&#xa;}&#xa;&#xa;//-----------------------&#xa;// == GLOBAL FUNCTION: == find node object for specific node ID&#xa;def findNodeByID(nodeID) {&#xa;    def theNode=null&#xa;    c.find{it.nodeID==nodeID}.each{&#xa;        theNode=it&#xa;    }&#xa;    return theNode&#xa;}&#xa;&#xa;//-----------------------&#xa;// == GLOBAL FUNCTION: == select node on Map by node ID and center the map on the node&#xa;def selectNodeByID(nodeID) {&#xa;    c.find{it.nodeID==nodeID}.each{&#xa;        c.select(it)&#xa;        c.centerOnNode(it)&#xa;        updateRecentNodesVisited(it.text)&#xa;    }&#xa;&#xa;}&#xa;&#xa;//-----------------------&#xa;// == GLOBAL FUNCTION: == select node object with specific title and center the map on the node&#xa;def selectNodeByTitle(nodeTitle) {&#xa;    c.find{it.text==nodeTitle}.each{&#xa;        c.select(it)&#xa;        c.centerOnNode(it)&#xa;        updateRecentNodesVisited(it.text)&#xa;    }&#xa;&#xa;}&#xa;&#xa;//-----------------------&#xa;// == GLOBAL FUNCTION: == copy a node and all its properties to a new node&#xa;def copyProperties(dest, source) {&#xa;    dest.text = source.text&#xa;    dest.attributes = source.attributes.map&#xa;    dest.link.text = source.link.text&#xa;    if (source.note != null)&#xa;        dest.note = source.note&#xa;    dest.details = source.detailsText&#xa;}&#xa;&#xa;&#xa;&#xa;// initialise recent nodes visited array&#xa;recentNodesVisited=[]&#xa;&#xa;//-----------------------&#xa;// == GLOBAL FUNCTION: == update recent nodes visited array&#xa;def updateRecentNodesVisited(newNodeTitle) {&#xa;    if (!recentNodesVisited.contains(newNodeTitle)) {&#xa;        if (recentNodesVisited.size()&gt;15) recentNodesVisited.pop()&#xa;        recentNodesVisited.add(0,newNodeTitle)&#xa;    }&#xa;}&#xa;&#xa;//-----------------------&#xa;// == GLOBAL FUNCTION: == prepare node core, note and detail texts for display in Swing UI elements&#xa;def formatForSwingDisplay(nodetype,text,note,details) {&#xa;    // In order to display node, note and detail text&#xa;    // in swing ui elements remove extraneous html tags&#xa;    // and format with &apos;clean&apos; HTML to keep Swing UI&#xa;    // elements happy&#xa;&#xa;    text=nodetype&#xa;    wrapafterchars=80&#xa;    wrapcharacter=&apos;\n&apos;&#xa;    String msgtext=&apos;&lt;HTML&gt;&lt;head&gt;&lt;/head&gt;&lt;body  style=\&quot;width: 250px;\&quot;&gt;&apos;&#xa;    if (text==null) text=&apos;empty&apos;&#xa;    text=text&#xa;            .replace(&apos;&lt;/html&gt;&apos;,&apos;&apos;)&#xa;            .replace(&apos;&lt;/HTML&gt;&apos;,&apos;&apos;)&#xa;            .replace(&apos;&lt;html&gt;&apos;,&apos;&apos;)&#xa;            .replace(&apos;&lt;HTML&gt;&apos;,&apos;&apos;)&#xa;            .replace(&apos;&lt;/head&gt;&apos;,&apos;&apos;)&#xa;            .replace(&apos;&lt;/HEAD&gt;&apos;,&apos;&apos;)&#xa;            .replace(&apos;&lt;head&gt;&apos;,&apos;&apos;)&#xa;            .replace(&apos;&lt;HEAD&gt;&apos;,&apos;&apos;)&#xa;            .replace(&apos;&lt;/body&gt;&apos;,&apos;&apos;)&#xa;            .replace(&apos;&lt;/BODY&gt;&apos;,&apos;&apos;)&#xa;            .replace(&apos;&lt;body&gt;&apos;,&apos;&apos;)&#xa;            .replace(&apos;&amp;#160;&apos;,&apos;&amp;nbsp;&apos;)&#xa;    text=wordwrap(text,wrapafterchars,wrapcharacter).trim()&#xa;    msgtext+=&quot;&lt;B&gt;&lt;font color=\&quot;blue\&quot;&gt;Title:&lt;/font&gt;&lt;/B&gt;&lt;HR&gt;&lt;B&gt;$text&lt;/B&gt;&lt;BR&gt;&quot;&#xa;    if (note==null) note=&apos;empty&apos;&#xa;    note=note&#xa;            .replace(&apos;&lt;/html&gt;&apos;,&apos;&apos;)&#xa;            .replace(&apos;&lt;/HTML&gt;&apos;,&apos;&apos;)&#xa;            .replace(&apos;&lt;html&gt;&apos;,&apos;&apos;)&#xa;            .replace(&apos;&lt;HTML&gt;&apos;,&apos;&apos;)&#xa;            .replace(&apos;&lt;/head&gt;&apos;,&apos;&apos;)&#xa;            .replace(&apos;&lt;/HEAD&gt;&apos;,&apos;&apos;)&#xa;            .replace(&apos;&lt;head&gt;&apos;,&apos;&apos;)&#xa;            .replace(&apos;&lt;HEAD&gt;&apos;,&apos;&apos;)&#xa;            .replace(&apos;&lt;/body&gt;&apos;,&apos;&apos;)&#xa;            .replace(&apos;&lt;/BODY&gt;&apos;,&apos;&apos;)&#xa;            .replace(&apos;&lt;body&gt;&apos;,&apos;&apos;)&#xa;            .replace(&apos;&amp;#160;&apos;,&apos;&amp;nbsp;&apos;)&#xa;    note=wordwrap(note,,wrapafterchars,wrapcharacter).trim()&#xa;    msgtext+=&quot;&lt;B&gt;&lt;font color=\&quot;blue\&quot;&gt;Note:&lt;/font&gt;&lt;/B&gt;&lt;HR&gt;$note&lt;BR&gt;&lt;BR&gt;&quot;&#xa;    if (details==null) details=&apos;empty&apos;&#xa;    details=details&#xa;            .replace(&apos;&lt;/html&gt;&apos;,&apos;&apos;)&#xa;            .replace(&apos;&lt;/HTML&gt;&apos;,&apos;&apos;)&#xa;            .replace(&apos;&lt;html&gt;&apos;,&apos;&apos;)&#xa;            .replace(&apos;&lt;HTML&gt;&apos;,&apos;&apos;)&#xa;            .replace(&apos;&lt;/head&gt;&apos;,&apos;&apos;)&#xa;            .replace(&apos;&lt;/HEAD&gt;&apos;,&apos;&apos;)&#xa;            .replace(&apos;&lt;head&gt;&apos;,&apos;&apos;)&#xa;            .replace(&apos;&lt;HEAD&gt;&apos;,&apos;&apos;)&#xa;            .replace(&apos;&lt;/body&gt;&apos;,&apos;&apos;)&#xa;            .replace(&apos;&lt;/ BODY&gt;&apos;,&apos;&apos;)&#xa;            .replace(&apos;&lt;body&gt;&apos;,&apos;&apos;)&#xa;            .replace(&apos;&amp;#160;&apos;,&apos;&amp;nbsp;&apos;)&#xa;    details=wordwrap(details,wrapafterchars,wrapcharacter).trim()&#xa;    msgtext+=&quot;&lt;B&gt;&lt;font color=\&quot;blue\&quot;&gt;Details:&lt;/font&gt;&lt;/B&gt;&lt;HR&gt;$details&lt;BR&gt;&quot;&#xa;    msgtext+=&quot;&quot;&quot;&lt;/body&gt;&lt;/HTML&gt;&quot;&quot;&quot;&#xa;&#xa;    return msgtext.replace(&apos;\n\n&apos;,&apos;&lt;BR&gt;&apos;).replace(&apos;\n&apos;,&apos;&lt;BR&gt;&apos;)&#xa;}&#xa;&#xa;&#xa;//-----------------------&#xa;// == GLOBAL FUNCTION: == word wrap text&#xa;def wordwrap(text, width=80, prefix=&apos;&apos;) {&#xa;    def out = &apos;&apos;&#xa;    def remaining = text.replaceAll(&quot;\n&quot;, &quot; &quot;)&#xa;    while (remaining) {&#xa;        def next = prefix + remaining&#xa;        def found = next.lastIndexOf(&apos; &apos;, width)&#xa;        if (found == -1) remaining = &apos;&apos;&#xa;        else {&#xa;            remaining = next.substring(found + 1)&#xa;            next = next[0..found]&#xa;        }&#xa;        out += next + &apos;\n&apos;&#xa;    }&#xa;    return out&#xa;}&#xa;&#xa;//-----------------------&#xa;// == GLOBAL FUNCTION: == strip HTML tags from text&#xa;def removeHtmlTags(text) {&#xa;    if (text!=null) {&#xa;        def strippedText = text.replaceAll(&apos;\n\\s*&apos;, &apos;\n&apos;) // remove extra spaces after line breaks&#xa;        strippedText = strippedText.replaceAll(&apos;&lt;.*?&gt;&apos;, &apos;&apos;) // remove anythiing in between &lt; and &gt;&#xa;        strippedText = strippedText.replaceAll(&apos;^\\s*&apos;, &apos;&apos;) // remove whitespace&#xa;        strippedText = strippedText.replaceAll(&apos;\n\n\n&apos;, &apos;\n&apos;) // replace multiple line feed with single line feed&#xa;        return strippedText&#xa;    } else return &quot;&quot;&#xa;}&#xa;&#xa;&#xa;//-----------------------&#xa;// == GLOBAL FUNCTION: == format text for display in table cell&#xa;def formatNodeTextForCell(nodetext) {&#xa;    maxCharsInCell=100&#xa;    nodetext=removeHtmlTags(nodetext).take(maxCharsInCell)&#xa;            .replace(&apos;&amp;#160;&apos;,&apos;&apos;)&#xa;    return nodetext&#xa;}&#xa;&#xa;&#xa;//-----------------------&#xa;// == GLOBAL FUNCTION: == clean up a word for comparisons&#xa;def cleanupWord(word) {&#xa;    cleanword=word.toLowerCase()&#xa;            .replace(&apos;.&apos;,&apos;&apos;) // remove full stops&#xa;            .replace(&apos;,&apos;,&apos;&apos;) // remove commas&#xa;            .replace(&apos;!&apos;,&apos;&apos;) // remove exclamation marks&#xa;            .replace(&quot;&apos;s&quot;,&apos;&apos;) // remove plurals&#xa;            .trim()          // remove leading and trailing blanks&#xa;    if (cleanword.endsWith(&apos;s&apos;)) { // remove plural from words ending in s and NOT ss&#xa;        if (!cleanword.endsWith(&apos;ss&apos;)) {&#xa;            cleanword=cleanword.substring(0,cleanword.length()-1)&#xa;        }&#xa;        if (cleanword.endsWith(&apos;&amp;&apos;)) {&#xa;            cleanword=cleanword.substring(0,cleanword.length()-1)&#xa;        }&#xa;    }&#xa;    return cleanword&#xa;}&#xa;&#xa;//-----------------------&#xa;// == GLOBAL FUNCTION: == set all connectors in the current node and subnodes to default color (GRAY)&#xa;def setAllConnectorsToDefaultColor() {&#xa;    // set all connectors to GRAY&#xa;    node.map.root.findAll().each {&#xa;        it.connectorsOut.each {&#xa;            it.setColor(Color.GRAY)&#xa;        }&#xa;    }&#xa;}&#xa;&#xa;//-----------------------&#xa;// == GLOBAL FUNCTION: == remove  All connectors in the current node and subnodes to default color (GRAY)&#xa;def removeAllConnectors() {&#xa;    // set all connectors to GRAY&#xa;    node.map.root.findAll().each {&#xa;        it.connectorsIn.each {&#xa;            node.removeConnector(it)&#xa;        }&#xa;        it.connectorsOut.each {&#xa;            node.removeConnector(it)&#xa;        }&#xa;    }&#xa;}&#xa;&#xa;//-----------------------&#xa;// == GLOBAL FUNCTION: == hide all connectors by setting color to WHITE&#xa;def hideAllConnectors() {&#xa;    // set all connectors to WHITE&#xa;    node.map.root.findAll().each {&#xa;        it.connectorsOut.each {&#xa;            it.setColor(Color.WHITE)&#xa;        }&#xa;    }&#xa;}&#xa;&#xa;// == GLOBAL FUNCTION: == unhide all connectors by setting color to default&#xa;def unhideAllConnectors() {&#xa;    setAllConnectorsToDefaultColor()&#xa;}&#xa;&#xa;// == GLOBAL FUNCTION: == unhide all connectors by setting color to default&#xa;def showConnectorsForCurrentNode() {&#xa;    // TODO Only show connectors in map for current node&#xa;    hideAllConnectors()&#xa;    // set current node connectors to GRAY&#xa;    newNode.connectorsOut.each {&#xa;        it.setColor(Color.GRAY)&#xa;    }&#xa;    newNode.connectorsIn.each {&#xa;        it.setColor(Color.GRAY)&#xa;    }&#xa;}&#xa;&#xa;//-----------------------&#xa;// == GLOBAL FUNCTION: == set all connectors in the current node and subnodes to default color (GRAY)&#xa;def showAllConnectorsWithLabel(label) {&#xa;    def searchtype=&quot;contains&quot;&#xa;    def searcharg=label&#xa;    if (label.startsWith(&apos;/&apos;) &amp;&amp; label.endsWith(&apos;/&apos;)) {&#xa;        searchtype=&quot;regex&quot;&#xa;        searcharg=label.substring(1,label.length()-1)&#xa;    }&#xa;&#xa;    // set all connectors to GRAY&#xa;    hideAllConnectors()&#xa;    node.map.root.findAll().each {&#xa;        it.connectorsIn.each {&#xa;            if (searchtype==&quot;contains&quot;) {&#xa;                if (it.middleLabel.toLowerCase().contains(searcharg.toLowerCase())) {&#xa;                    it.setColor(Color.RED)&#xa;                }&#xa;            }&#xa;            if (searchtype==&quot;regex&quot;) {&#xa;                if (it.middleLabel=~searcharg) {&#xa;                    it.setColor(Color.BLUE)&#xa;                }&#xa;            }&#xa;        }&#xa;        it.connectorsOut.each {&#xa;            if (searchtype==&quot;contains&quot;) {&#xa;                if (it.middleLabel.toLowerCase().contains(searcharg.toLowerCase())) {&#xa;                    it.setColor(Color.RED)&#xa;                }&#xa;            }&#xa;            if (searchtype==&quot;regex&quot;) {&#xa;                if (it.middleLabel=~searcharg) {&#xa;                    it.setColor(Color.BLUE)&#xa;                }&#xa;            }&#xa;        }&#xa;    }&#xa;}&#xa;&#xa;&#xa;//-----------------------&#xa;// == GLOBAL FUNCTION: == populate the working array with&#xa;// (1) the parent node details&#xa;// (2) children node details&#xa;// (3) connections in/out details&#xa;def loadNodeData(node) {&#xa;    // load node data&#xa;    //&#xa;&#xa;    // get parent node details&#xa;    def nodeparenttext = &apos;root&apos;&#xa;    def nodeparentnotetext = &apos;&apos;&#xa;    def nodeparentdetailstext = &apos;&apos;&#xa;    def nodeparentID = null&#xa;&#xa;    if (node.parent != null) {&#xa;        nodeparenttext = node.parent.text&#xa;        nodeparentnotetext = node.parent.noteText&#xa;        nodeparentdetailstext = node.parent.detailsText&#xa;        nodeparentID = node.parent.nodeID&#xa;    }&#xa;&#xa;    // clear working array&#xa;    nodes_data = []&#xa;&#xa;    // add parent node info of selected node to working array&#xa;    nodes_data.add([id: nodeparentID, type: &apos;parent&apos;, nodetext: nodeparenttext, label: &apos;parent&apos;, notetext: nodeparentnotetext, details: nodeparentdetailstext])&#xa;&#xa;    // add child node(s) info of selected node to working array&#xa;    if (node.children) {&#xa;        node.children.each {&#xa;            nodes_data.add([id: it.nodeID, type: &apos;child&apos;, nodetext: it.text, label: &apos;child&apos;, notetext: it.noteText, details: it.detailsText])&#xa;        }&#xa;    }&#xa;&#xa;    // add info for any connections (source nodes) into this selected node into the working array&#xa;    if (node.connectorsIn) {&#xa;        node.connectorsIn.each {&#xa;            if (node != it.source) {&#xa;                def middleLabel = &quot;&lt;-&quot;&#xa;                if (it.middleLabel != null) {&#xa;                    middleLabel = it.middleLabel&#xa;                }&#xa;                sourceNode = getNodeByID(it.delegate.source.id)&#xa;                nodes_data.add([id: it.source.nodeID, type: &apos;conn-IN&apos;, nodetext: it.source.text, label: middleLabel, notetext: sourceNode.noteText, details: sourceNode.detailsText])&#xa;            }&#xa;        }&#xa;    }&#xa;&#xa;    // add info for any connections out (target nodes) from this selected node into the working array&#xa;    if (node.connectorsOut) {&#xa;        node.connectorsOut.each {&#xa;            if (node != it.target) {&#xa;                def middleLabel = &quot;-&gt;&quot;&#xa;                if (it.middleLabel != null) {&#xa;                    middleLabel = it.middleLabel&#xa;                }&#xa;                targetNode = getNodeByID(it.delegate.targetID)&#xa;                targetnoteText = targetNode.noteText.toString()&#xa;                nodes_data.add([id: it.target.nodeID, type: &apos;conn-OUT&apos;, nodetext: it.target.text, label: middleLabel, notetext: targetnoteText, details: targetNode.detailsText])&#xa;            }&#xa;        }&#xa;    }&#xa;    updateRecentNodesVisited(node.text)&#xa;    newNode=node&#xa;}&#xa;&#xa;//-----------------------&#xa;// == GLOBAL FUNCTION: == checks if the nodeID is not present in the working arrays which are visible in the ui Tables&#xa;def nodeIDNotInCurrentTables(nodeID) {&#xa;    def result=true&#xa;    if (connection_candidates_nodes_data.find { it.id==nodeID }) result=false&#xa;    return result&#xa;}&#xa;&#xa;&#xa;//-----------------------&#xa;// == GLOBAL FUNCTION: == Update the user interface (UI) tables from the working array for the selected node&#xa;def updateUI (newNode) {&#xa;    selected_node_button.text=formatNodeTextForCell(newNode.text)&#xa;    selected_node_button.setToolTipText(formatSelectedNodeButtonToolTipText(newNode))&#xa;    frame.title=&quot;$scriptVersion&quot;&#xa;    connectorsInTable.model = swing.tableModel(list: nodes_data.findAll{it.type==&quot;conn-IN&quot;}) {&#xa;        propertyColumn(header: &apos;Type&apos;, propertyName: &apos;type&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;        propertyColumn(header: &apos;Node&apos;, propertyName: &apos;nodetext&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;        propertyColumn(header: &apos;Note&apos;, propertyName: &apos;notetext&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;        propertyColumn(header: &apos;Details&apos;, propertyName: &apos;details&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;        propertyColumn(header: &apos;Label&apos;, propertyName: &apos;label&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;    }&#xa;    parentTable.model = swing.tableModel(list: nodes_data.findAll{it.type==&quot;parent&quot;}) {&#xa;        propertyColumn(header: &apos;Type&apos;, propertyName: &apos;type&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;        propertyColumn(header: &apos;Node&apos;, propertyName: &apos;nodetext&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;        propertyColumn(header: &apos;Note&apos;, propertyName: &apos;notetext&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;        propertyColumn(header: &apos;Details&apos;, propertyName: &apos;details&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;        propertyColumn(header: &apos;Label&apos;, propertyName: &apos;label&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;    }&#xa;    childrenTable.model = swing.tableModel(list: nodes_data.findAll{it.type==&quot;child&quot;}) {&#xa;        propertyColumn(header: &apos;Type&apos;, propertyName: &apos;type&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;        propertyColumn(header: &apos;Node&apos;, propertyName: &apos;nodetext&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;        propertyColumn(header: &apos;Note&apos;, propertyName: &apos;notetext&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;        propertyColumn(header: &apos;Details&apos;, propertyName: &apos;details&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;        propertyColumn(header: &apos;Label&apos;, propertyName: &apos;label&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;    }&#xa;    connectorsOutTable.model = swing.tableModel(list: nodes_data.findAll{it.type==&quot;conn-OUT&quot;}) {&#xa;        propertyColumn(header: &apos;Type&apos;, propertyName: &apos;type&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;        propertyColumn(header: &apos;Node&apos;, propertyName: &apos;nodetext&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;        propertyColumn(header: &apos;Note&apos;, propertyName: &apos;notetext&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;        propertyColumn(header: &apos;Details&apos;, propertyName: &apos;details&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;        propertyColumn(header: &apos;Label&apos;, propertyName: &apos;label&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;    }&#xa;    setColumnsForDisplay()&#xa;    setConnectorLabelsForDisplay()&#xa;    frame.pack()&#xa;    frame.show()&#xa;}&#xa;&#xa;// ===============================================================&#xa;// ====================== UI Functions ===========================&#xa;// ===============================================================&#xa;&#xa;// this class overrides the standard table cell renderer in the tables&#xa;// populated from the working arrays&#xa;// Each table cell contains a nodes core text. A tooltip displays&#xa;// the nodes note and detail text&#xa;&#xa;class MainTableCellRenderer extends JLabel implements TableCellRenderer {&#xa;    public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected,&#xa;                                                   boolean hasFocus, int rowIndex, int vColIndex) {&#xa;&#xa;&#xa;        //*********************************************&#xa;        // set the text for the cell&#xa;        //*********************************************&#xa;        //def displaytext=formatNodeTextForCell(value.toString())&#xa;        setText(value.toString())&#xa;&#xa;&#xa;        // set the cell to text and connector label (if row is showing a connector OUT)&#xa;        if (table.model.getValueAt(rowIndex,0)==&apos;conn-OUT&apos;) {&#xa;            setText(&apos;(&apos; + table.model.getValueAt(rowIndex, 4) + &apos;) &apos;+removeHtmlTags(value.toString()))&#xa;        }&#xa;&#xa;        // set the cell to text and connector label (if row is showing a connector IN)&#xa;        if (table.model.getValueAt(rowIndex,0)==&apos;conn-IN&apos;) {&#xa;            setText(removeHtmlTags(value.toString() + &apos; (&apos; + table.model.getValueAt(rowIndex, 4)) + &apos;)&apos;)&#xa;        }&#xa;&#xa;        // center the text in the cell&#xa;        setHorizontalAlignment(SwingConstants.CENTER)&#xa;&#xa;        // color the cell based on whether the referred node is&#xa;        // a parent of the selected node&#xa;        // a child of the selected node&#xa;        // a connection into or out of the selected node&#xa;        if (table.model.getValueAt(rowIndex,0)==&apos;parent&apos;) setForeground(new Color(0,102,0))&#xa;        if (table.model.getValueAt(rowIndex,0)==&apos;child&apos;) setForeground(Color.BLUE)&#xa;        if (table.model.getValueAt(rowIndex,0)==&apos;conn-IN&apos;) setForeground(Color.RED)&#xa;        if (table.model.getValueAt(rowIndex,0)==&apos;conn-OUT&apos;) setForeground(new Color(153,0,0))&#xa;        if (vColIndex==0) {&#xa;            setForeground(Color.WHITE)&#xa;        }&#xa;        //*****************************************************&#xa;        // Set up tooltip for cell which shows the note and&#xa;        // detail texts related to the node the cell refers to&#xa;        //*****************************************************&#xa;&#xa;&#xa;        // show connector labels for connectors in and out in the tooltip&#xa;        String nodetype=removeHtmlTags(value.toString())+&apos;&lt;HR&gt;&apos;+table.model.getValueAt(rowIndex,0)+&apos;&lt;HR&gt;&apos;&#xa;        if (table.model.getValueAt(rowIndex,0)==&apos;conn-IN&apos; || table.model.getValueAt(rowIndex,0)==&apos;conn-OUT&apos;) {&#xa;            nodetype=removeHtmlTags(value.toString())+&apos;&lt;HR&gt;&apos;+table.model.getValueAt(rowIndex,0)+&apos; (&apos;+table.model.getValueAt(rowIndex,4)+&apos;)&apos;+&apos;&lt;HR&gt;&apos;&#xa;        }&#xa;&#xa;        // show the node&apos;s note text&#xa;        String notetext=table.model.getValueAt(rowIndex,2)&#xa;        if (notetext==null) notetext=&quot;empty&quot;&#xa;&#xa;        // show the node&apos;s details text&#xa;        String detailstext=table.model.getValueAt(rowIndex,3)&#xa;        if (detailstext==null) detailstext=&quot;empty&quot;&#xa;&#xa;        // format the tooltip for display&#xa;        def tooltiptext= &quot;&lt;html&gt;&lt;br&gt;&quot; + formatForSwingDisplay(nodetype,value,notetext,detailstext)&#xa;&#xa;        // attach tooltip to the cell&#xa;        setToolTipText((String) tooltiptext)&#xa;&#xa;        return this&#xa;    }&#xa;}&#xa;&#xa;//-----------------------&#xa;// == UI FUNCTION: == display the details for a node selected in a UI table&#xa;def displayNewNode(tab,nodes_data) {&#xa;    def nodedata=nodes_data[tab.getSelectedRow(),tab.getSelectedColumn()][0]&#xa;    def theNode=getNodeByID(nodedata[&quot;id&quot;])&#xa;    selectNodeByID(nodedata[&quot;id&quot;])&#xa;    loadNodeData(theNode)&#xa;    updateUI(theNode)&#xa;}&#xa;&#xa;//-----------------------&#xa;// == UI FUNCTION: == display the details for the source and target notes for a node candidate&#xa;def displayConnection(tab,nodes_data,candidatenodeID) {&#xa;    def nodedata=nodes_data[tab.getSelectedRow(),tab.getSelectedColumn()][0]&#xa;    def a=1&#xa;//    def theNode=getNodeByID(nodedata[&quot;id&quot;])&#xa;//    selectNodeByID(nodedata[&quot;id&quot;])&#xa;//    loadNodeData(theNode)&#xa;//    updateUI(theNode)&#xa;}&#xa;&#xa;//-----------------------&#xa;// == UI FUNCTION: == Set the display widths for the UI&#xa;def setColumnsForDisplay() {&#xa;&#xa;    // set width of parent table which forces panel to the minWidth value&#xa;    minWidth=300&#xa;    parentTable.getColumn(&apos;nodetext&apos;).setMinWidth(minWidth)&#xa;&#xa;    HideTableColumns(parentTable,[&apos;type&apos;,&apos;notetext&apos;,&apos;details&apos;,&apos;label&apos;])&#xa;    HideTableColumns(childrenTable,[&apos;type&apos;,&apos;notetext&apos;,&apos;details&apos;,&apos;label&apos;])&#xa;    HideTableColumns(connectorsInTable,[&apos;type&apos;,&apos;notetext&apos;,&apos;details&apos;,&apos;label&apos;])&#xa;    HideTableColumns(connectorsOutTable,[&apos;type&apos;,&apos;notetext&apos;,&apos;details&apos;,&apos;label&apos;])&#xa;}&#xa;&#xa;//-----------------------&#xa;// == UI FUNCTION: == Hide one or more table columns&#xa;def HideTableColumns(table,columns) {&#xa;    columns.each {&#xa;        try {&#xa;            table.getColumn(it).setWidth(0)&#xa;            table.getColumn(it).setMinWidth(0)&#xa;            table.getColumn(it).setMaxWidth(0)&#xa;        } catch(all) {&#xa;            // ignore if column not found&#xa;        }&#xa;    }&#xa;}&#xa;&#xa;//-----------------------&#xa;// == UI FUNCTION: == Set the connection labels based on whether connections or children are present for the selected node&#xa;def setConnectorLabelsForDisplay() {&#xa;    if (nodes_data.find{it.type==&quot;conn-IN&quot;}) {&#xa;        conn_in_label.setVisible(true)&#xa;    } else {&#xa;        conn_in_label.setVisible(false)&#xa;    }&#xa;    if (nodes_data.find{it.type==&quot;conn-OUT&quot;}) {&#xa;        conn_out_label.setVisible(true)&#xa;    } else {&#xa;        conn_out_label.setVisible(false)&#xa;    }&#xa;    if (nodes_data.find{it.type==&quot;child&quot;}) {&#xa;        children_label.setVisible(true)&#xa;    } else {&#xa;        children_label.setVisible(false)&#xa;    }&#xa;}&#xa;&#xa;//-----------------------&#xa;// == UI FUNCTION: == Set the connection labels based on whether connections or children are present for the selected node&#xa;def setButtonsForDisplay() {&#xa;    selected_node_button.setToolTipText(formatSelectedNodeButtonToolTipText(newNode))&#xa;}&#xa;&#xa;//-----------------------&#xa;// == UI FUNCTION: == format tooltip for the selected node button&#xa;def formatSelectedNodeButtonToolTipText(selectednode) {&#xa;    return &quot;&lt;html&gt;&lt;b&gt;Selected Node&lt;/b&gt;&lt;br&gt;&lt;br&gt;&quot; +&#xa;            formatForSwingDisplay(selectednode.text + &apos;&lt;br&gt;&apos;,&#xa;                    selectednode.text,&#xa;                    selectednode.noteText,&#xa;                    selectednode.detailsText).replace(&apos;&lt;html&gt;&apos;, &apos;&apos;)&#xa;}&#xa;&#xa;&#xa;&#xa;//*********************************************&#xa;//*********************************************&#xa;//*********************************************&#xa;//         MAIN LOGIC ENTRY POINT&#xa;//*********************************************&#xa;//*********************************************&#xa;//*********************************************&#xa;&#xa;// load the data from the currently selected node&#xa;loadNodeData(node)&#xa;&#xa;Color tablebg = new Color(224,224,224)&#xa;&#xa;&#xa;// ===============================================================&#xa;// ============== THE USER INTERFACE DEFINITION   ================&#xa;// ===============================================================&#xa;&#xa;//         BASIC LAYOUT FOR DISPLAYING SELECTED NODE&#xa;//                 -------------------------&#xa;//                 | Menus                 |&#xa;//                 -------------------------&#xa;//                 |                       |&#xa;//                 |      PARENT NODE      |&#xa;//                 |          v            |&#xa;//                 |       CONNECTED       |&#xa;//                 |         NODES         |&#xa;//                 |          IN           |&#xa;//                 |          v            |&#xa;//                 |     ------------      |&#xa;//                 |     | SELECTED |      |&#xa;//                 |     |   NODE   |      |&#xa;//                 |     ------------      |&#xa;//                 |          v            |&#xa;//                 |       CONNECTED       |&#xa;//                 |         NODES         |&#xa;//                 |         OUT           |&#xa;//                 |          v            |&#xa;//                 |      CHILD NODES      |&#xa;//                 |                       |&#xa;//                 -------------------------&#xa;&#xa;// create a groovy SwingBuilder&#xa;swing = new SwingBuilder()&#xa;&#xa;// define the main ui window(frame)&#xa;frame = swing.frame(title: &quot;$scriptVersion&quot;, defaultCloseOperation: JFrame.DISPOSE_ON_CLOSE, alwaysOnTop: true,minimumSize: new Dimension(400,25)) {&#xa;    // main panel&#xa;    mypanel = panel (background: tablebg) {&#xa;        gridLayout()&#xa;        vbox {&#xa;&#xa;            // Menu panel&#xa;            panel(background: tablebg) {&#xa;                gridLayout()&#xa;                mainmenu=menuBar(minimumSize: new Dimension(400,25),maximumSize: new Dimension(400,25)) {&#xa;                    menu(text:&apos;Actions&apos;) {&#xa;                        menuItem() {&#xa;                            action(&#xa;                                    name:&quot;open selected map node&quot;, closure:{&#xa;                                newNode = getNodeFromMapSelection()&#xa;                                loadNodeData(newNode)&#xa;                                updateUI(newNode)&#xa;                            })&#xa;                        }&#xa;                        separator()&#xa;                        menuItem() {&#xa;                            action(&#xa;                                    name:&quot;Go to Root Node&quot;, closure:{&#xa;                                newNode=newNode.map.root&#xa;                                loadNodeData(newNode.map.root)&#xa;                                updateUI(newNode.map.root)&#xa;                            })&#xa;                        }&#xa;                        menuItem() {&#xa;                            action(&#xa;                                    name:&quot;Refresh current view&quot;, closure:{&#xa;                                loadNodeData(newNode)&#xa;                                updateUI(newNode)&#xa;                            })&#xa;                        }&#xa;                        separator()&#xa;                    }&#xa;                    menu(text:&apos;View&apos;) {&#xa;                        menuItem() {&#xa;                            action(name:&quot;Node Details&quot;,&#xa;                                    closure:{&#xa;                                        if (newNode!=null) {&#xa;                                            def notetext=&apos;empty&apos;&#xa;                                            if (newNode.noteText!=null) {&#xa;                                                notetext=newNode.noteText&#xa;                                            }&#xa;                                            def detailstext=&apos;empty&apos;&#xa;                                            if (newNode.detailsText!=null) {&#xa;                                                detailstext=newNode.detailsText&#xa;                                            }&#xa;                                            msgtext=formatForSwingDisplay(newNode.text,newNode.text,notetext,detailstext)&#xa;                                            msg=label(msgtext)&#xa;                                            def pane = swing.optionPane(message: msg)&#xa;                                            def dialog = pane.createDialog(frame, &apos;Note&apos;)&#xa;                                            dialog.show()&#xa;                                        }&#xa;                                    })&#xa;                        }&#xa;                        separator()&#xa;                        menu(text:&apos;Connectors&apos;) {&#xa;                            menuItem() {&#xa;                                action(name:&quot;Connector Candidates&quot;,&#xa;                                        closure:{&#xa;                                            connectoroptions()&#xa;                                        })&#xa;                            }&#xa;                            separator()&#xa;                            menuItem() {&#xa;                                action(name: &quot;Connectors Manager&quot;,&#xa;                                        closure: {&#xa;                                            connectorManagerUI()&#xa;                                        })&#xa;                            }&#xa;                            separator()&#xa;                            menuItem() {&#xa;                                action(name: &quot;Show Current Node Connectors&quot;,&#xa;                                        closure: {&#xa;                                            if (newNode!=null) {&#xa;                                                showConnectorsForCurrentNode()&#xa;                                            }&#xa;                                        })&#xa;                            }&#xa;                            separator()&#xa;                            menuItem() {&#xa;                                action(name: &quot;Show Connectors for a label&quot;,&#xa;                                        closure: {&#xa;                                            def pane = swing.optionPane()&#xa;                                            def label = pane.showInputDialog(null,&quot;Enter full or partial label text\n OR a regular expression eg /M.*h/&quot;,&quot;Connector Label Search&quot;,JOptionPane.QUESTION_MESSAGE)&#xa;                                            showAllConnectorsWithLabel(label)&#xa;                                        })&#xa;                            }&#xa;                            separator()&#xa;                            menuItem() {&#xa;                                action(name: &quot;Hide All Connectors&quot;,&#xa;                                        closure: {&#xa;                                            hideAllConnectors()&#xa;                                        })&#xa;                            }&#xa;                            separator()&#xa;                            menuItem() {&#xa;                                action(name: &quot;UnHide All Connectors&quot;,&#xa;                                        closure: {&#xa;                                            unhideAllConnectors()&#xa;                                        })&#xa;                            }&#xa;                            separator()&#xa;                        }&#xa;                    }&#xa;                    menu(text:&apos;History&apos;) {&#xa;                        menuItem() {&#xa;                            action(name:&apos;Recent Nodes Visited&apos;,&#xa;                                    closure:{&#xa;                                        if (recenthistoryDisplayed==true || recentNodesVisited.size==0) {&#xa;                                            return&#xa;                                        }&#xa;                                        recenthistoryDisplayed=true&#xa;                                        swing.setVariable(&apos;Recent Nodes Visited&apos;,[:])&#xa;                                        def vars = swing.variables&#xa;                                        dial = swing.dialog(title:&apos;Recent Nodes Visited&apos;,&#xa;                                                id:&apos;recentDialog&apos;,&#xa;                                                minimumSize: [300,50],&#xa;                                                modal:true,&#xa;                                                location: [mypanel.getAt(&apos;width&apos;)+5,0],&#xa;//                                                locationRelativeTo: ui.frame,&#xa;                                                owner:ui.frame,&#xa;                                                defaultCloseOperation:JFrame.DO_NOTHING_ON_CLOSE,&#xa;                                                //                    Using DO_NOTHING_ON_CLOSE so the Close button has full control&#xa;                                                //                    and it can ensure only one instance of the dialog appears&#xa;                                                pack:true,&#xa;                                                show:true) {&#xa;                                            panel() {&#xa;                                                boxLayout(axis: BoxLayout.Y_AXIS)&#xa;                                                recentspanel=panel(alignmentX: 0f) {&#xa;                                                    flowLayout(alignment: FlowLayout.LEFT)&#xa;                                                    recentlist=list(id: &apos;type&apos;, items: recentNodesVisited)&#xa;                                                }&#xa;                                                panel(alignmentX: 0f) {&#xa;                                                    flowLayout(alignment: FlowLayout.RIGHT)&#xa;                                                    button(action: action(name: &apos;Locate&apos;, defaultButton: true,&#xa;                                                            closure: {&#xa;                                                                // locate the node selected in the table and go to it in the map&#xa;                                                                // but do not load it into Map Insights array&#xa;                                                                vars.ok=true&#xa;                                                                c.find{&#xa;                                                                    it.text == vars.type.selectedValue&#xa;                                                                }.each {&#xa;                                                                    selectNodeByTitle(it.text)&#xa;                                                                }&#xa;//                                                                                recentDialog.dispose()&#xa;                                                            }))&#xa;                                                    button(action: action(name: &apos;Go To&apos;, defaultButton: true,&#xa;                                                            closure: {&#xa;                                                                // locate the node selected in the table and go to it in the map&#xa;                                                                // and load it into Map Insights array as the main node for Map Insight&#xa;                                                                vars.ok=true&#xa;                                                                c.find{&#xa;                                                                    it.text == vars.type.selectedValue&#xa;                                                                }.each {&#xa;                                                                    selectNodeByTitle(it.text)&#xa;                                                                    newNode=c.selected&#xa;                                                                    loadNodeData(newNode)&#xa;                                                                    updateUI(newNode)&#xa;                                                                }&#xa;                                                                recentDialog.dispose()&#xa;                                                                recenthistoryDisplayed=false&#xa;                                                            }))&#xa;                                                    button(action: action(name: &apos;Close&apos;, closure: {&#xa;                                                        recenthistoryDisplayed=false&#xa;                                                        recentDialog.dispose()&#xa;                                                    }))&#xa;                                                }&#xa;                                            }&#xa;                                        }&#xa;                                    }&#xa;                            )&#xa;                        }&#xa;                    }&#xa;                    menu(text:&apos;Help&apos;) {&#xa;                        menuItem() {&#xa;                            action(name:&apos;About&apos;, closure:{&#xa;                                def pane = swing.optionPane(message: &quot;&lt;html&gt;$scriptVersion&lt;p&gt;&lt;small&gt;Author: Allan Davies&gt;&lt;br&gt;&lt;i&gt;ADXSoft&lt;/i&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;https://github.com/adxsoft/MapInsight&lt;/small&gt;&lt;/html&gt;&quot;)&#xa;                                def dialog = pane.createDialog(frame, scriptVersion)&#xa;                                dialog.show()&#xa;                            })}&#xa;                        menuItem() {&#xa;                            action(name:&apos;Installation&apos;, closure:{&#xa;                                def pane = swing.optionPane(message: installation)&#xa;                                def dialog = pane.createDialog(frame, &quot;Installing in Freeplane&quot;)&#xa;                                dialog.show()&#xa;                            })}&#xa;                        menuItem() {&#xa;                            action(name:&apos;Using Map Insight&apos;, closure:{&#xa;                                def pane = swing.optionPane(message: helptext1)&#xa;                                def dialog = pane.createDialog(frame, &quot;using Map Insight&quot;)&#xa;                                dialog.show()&#xa;                            })}&#xa;                        menuItem() {&#xa;                            action(name:&apos;Finding Connections&apos;, closure:{&#xa;                                def pane = swing.optionPane(message: helptext2)&#xa;                                def dialog = pane.createDialog(frame, &quot;Finding Connections&quot;)&#xa;                                dialog.show()&#xa;                            })}&#xa;                        menuItem() {&#xa;                            action(name:&apos;Managing Connectors&apos;, closure:{&#xa;                                def pane = swing.optionPane(message: helptext3)&#xa;                                def dialog = pane.createDialog(frame, &quot;Managing Connectors&quot;)&#xa;                                dialog.show()&#xa;                            })}&#xa;                        menuItem() {&#xa;                            action(name:&apos;Version History&apos;, closure:{&#xa;                                def pane = swing.optionPane(message: versionhistory)&#xa;                                def dialog = pane.createDialog(frame, &quot;Version History&quot;)&#xa;                                dialog.show()&#xa;                            })}&#xa;                    }&#xa;                }&#xa;            }&#xa;&#xa;            // main central container has five areas arranged vertically&#xa;            // that show the relationships of the selected node&#xa;&#xa;            // 1st area is the selected node&apos;s parent node in a table&#xa;            // 2nd area is any incomming connectors to the selected node&#xa;            // 3rd area is the selected node as a white button&#xa;            // 4th are is any outgoing connectors from the selected node&#xa;            // 5th area is the children of the selected node in a scrollable table&#xa;&#xa;            centralContainer=scrollPane(background: tablebg) {&#xa;                vbox {&#xa;                    // Parent node details in table (note using customised table renderer MainTableCellRenderer)&#xa;                    vbox {&#xa;                        parentTable = table(background: tablebg, showGrid: false, gridColor: Color.GRAY) {&#xa;                            editing: true&#xa;                            tableModel(list: nodes_data.findAll { it.type == &quot;parent&quot; }) {&#xa;                                propertyColumn(header: &apos;Type&apos;, propertyName: &apos;type&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;                                propertyColumn(header: &apos;Node&apos;, propertyName: &apos;nodetext&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;                                propertyColumn(header: &apos;Note&apos;, propertyName: &apos;notetext&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;                                propertyColumn( header: &apos;Details&apos;, propertyName: &apos;details&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;                                propertyColumn(header: &apos;Label&apos;, propertyName: &apos;label&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;                            }&#xa;                        }&#xa;                    }&#xa;&#xa;                    // markers to denote parent relationship to selected node below&#xa;                    parent_label = panel(background: tablebg) {label(text: &quot;v&quot;,opaque: true,background: tablebg)}&#xa;                    // Connectors In details in table (note using customised table renderer MainTableCellRenderer)&#xa;                    vbox {&#xa;                        hbox {&#xa;                            connectorsInTable = table(background: tablebg, showGrid: false, gridColor: Color.GRAY) {&#xa;                                editing: true&#xa;                                model = tableModel(list: nodes_data.findAll { it.type == &quot;conn-IN&quot; }) {&#xa;                                    propertyColumn(header: &apos;Type&apos;, propertyName: &apos;type&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;                                    propertyColumn(header: &apos;Node&apos;, propertyName: &apos;nodetext&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;                                    propertyColumn(header: &apos;Note&apos;, propertyName: &apos;notetext&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;                                    propertyColumn(header: &apos;Details&apos;, propertyName: &apos;details&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;                                    propertyColumn(header: &apos;Label&apos;, propertyName: &apos;label&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;                                }&#xa;                            }&#xa;                        }&#xa;                    }&#xa;&#xa;                    // markers to denote parent relationship to selected node below&#xa;                    conn_in_label = panel(background: tablebg) {label(text: &quot;v&quot;,opaque: true,background: tablebg)}&#xa;&#xa;                    // currently selected node area&#xa;                    vbox {&#xa;                        panel(background: tablebg) {&#xa;                            flowLayout()&#xa;                            hbox {&#xa;                                selected_node_button = button(&#xa;                                        background: Color.WHITE,&#xa;                                        margin: new Insets(10, 10, 10, 10),&#xa;                                        contentAreaFilled: false,&#xa;                                        opaque: true&#xa;                                ) {&#xa;                                    action(name: formatNodeTextForCell(newNode.text)) {&#xa;                                        selectNodeByID(newNode.nodeID)&#xa;                                    }&#xa;                                }&#xa;                            }&#xa;&#xa;                        }&#xa;                    }&#xa;&#xa;                    // markers to denote child relationship to selected node above&#xa;                    conn_out_label = panel(background: tablebg) {label(text: &quot;v&quot;,opaque: true,background: tablebg)}&#xa;&#xa;                    vbox {&#xa;                        hbox {&#xa;                            connectorsOutTable = table(background: tablebg, showGrid: false, gridColor: Color.GRAY) {&#xa;                                editing: true&#xa;                                model = tableModel(list: nodes_data.findAll { it.type == &quot;conn-OUT&quot; }) {&#xa;                                    propertyColumn(header: &apos;Type&apos;, propertyName: &apos;type&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;                                    propertyColumn(header: &apos;Node&apos;, propertyName: &apos;nodetext&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;                                    propertyColumn(header: &apos;Note&apos;, propertyName: &apos;notetext&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;                                    propertyColumn(header: &apos;Details&apos;, propertyName: &apos;details&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;                                    propertyColumn(header: &apos;Label&apos;, propertyName: &apos;label&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;                                }&#xa;                            }&#xa;                        }&#xa;                    }&#xa;&#xa;                    children_label = panel(background: tablebg) {label(text: &quot;v&quot;,opaque: true,background: tablebg)}&#xa;&#xa;                    // Children node details in table (note using customised table renderer MainTableCellRenderer)&#xa;                    vbox {&#xa;                        childrenTable = table(background: tablebg, showGrid: false, gridColor: Color.GRAY) {&#xa;                            editing: true&#xa;                            model = tableModel(list: nodes_data.findAll { it.type == &quot;child&quot; }) {&#xa;                                propertyColumn(header: &apos;Type&apos;, propertyName: &apos;type&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;                                propertyColumn(header: &apos;Node&apos;, propertyName: &apos;nodetext&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;                                propertyColumn(header: &apos;Note&apos;, propertyName: &apos;notetext&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;                                propertyColumn(header: &apos;Details&apos;, propertyName: &apos;details&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;                                propertyColumn(header: &apos;Label&apos;, propertyName: &apos;label&apos;, editable: false, cellRenderer: new MainTableCellRenderer())&#xa;                            }&#xa;                        }&#xa;                    }&#xa;//                    label(text: &apos;  &apos;) // spacer&#xa;                } // end vbox&#xa;            }&#xa;        }&#xa;    }&#xa;}&#xa;&#xa;// Display the Main User Interface&#xa;setColumnsForDisplay()&#xa;setConnectorLabelsForDisplay()&#xa;setButtonsForDisplay()&#xa;frame.pack()&#xa;frame.show()&#xa;mapInsightDisplayed=true&#xa;&#xa;connection_candidates_nodes_data = []&#xa;connection_candidates_nodes_saved_objects = []&#xa;&#xa;&#xa;//-----------------------&#xa;// == UI FUNCTION: == Connector Candidates&#xa;// Shows options for finding connector candidates&#xa;// Candidates are selected based on words derived from core text&#xa;// and/or notes text&#xa;// and/or details text&#xa;// and/or specific user entered words&#xa;def connectoroptions() {&#xa;    useSourceNodeCoreText=true&#xa;    useSourceNodeNoteText=false&#xa;    useSourceNodeDetailsText=false&#xa;    useWords=false&#xa;    useWordsText=&quot;&quot;&#xa;    searchTargetNodeNoteText=false&#xa;    searchTargetNodeDetailsText=false&#xa;&#xa;    connectoroptionsdialog = swing.dialog(&#xa;            title: &quot;Connector Candidate Options&quot;,&#xa;            defaultCloseOperation: JFrame.DISPOSE_ON_CLOSE,&#xa;            alwaysOnTop: true,&#xa;            modal: false,&#xa;            location: [mypanel.getAt(&apos;width&apos;)+5,0]&#xa;    )&#xa;    def panel = swing.panel{&#xa;        vbox {&#xa;            vbox{&#xa;                checkBox(id: &apos;cb4&apos;,text:&quot;Use the words below&quot;,selected: useWords,&#xa;                        actionPerformed: {&#xa;                            useWords=cb4.selected&#xa;                            cb1.selected=false&#xa;                            cba.selected=true&#xa;                            cbb.selected=true&#xa;                            cbc.selected=true&#xa;                            searchTargetNodeCoreText=true&#xa;                            searchTargetNodeNoteText=true&#xa;                            searchTargetNodeDetailsText=true&#xa;                            input.requestFocus()&#xa;                        })&#xa;                label(text: &quot;&quot;&quot;&lt;html&gt;&#xa;                                &lt;body&gt;&#xa;                                    eg word1,word2,word3 or&lt;br&gt;&#xa;                                    &amp;nbsp;&amp;nbsp; a single phrase in double quotes eg &quot;united kingdom&quot;&lt;br&gt;&#xa;                                    &amp;nbsp;&amp;nbsp; a regular expression in forward slashes eg &quot;/^M*/&#xa;                                &lt;/body&gt;&#xa;                                &lt;/html&gt;&quot;&quot;&quot;)&#xa;                input = textField(columns:20)&#xa;                separator()&#xa;                label(text: &apos;For the current node&apos;)&#xa;                checkBox(id: &apos;cb1&apos;,text:&quot;Use words from CORE TEXT&quot;,selected: useSourceNodeCoreText,actionPerformed: {useSourceNodeCoreText=cb1.selected})&#xa;                checkBox(id: &apos;cb2&apos;,text:&quot;Use words from NOTE TEXT&quot;,selected: useSourceNodeNoteText,actionPerformed: {useSourceNodeNoteText=cb2.selected})&#xa;                checkBox(id: &apos;cb3&apos;,text:&quot;Use words from DETAILS TEXT&quot;,selected: useSourceNodeDetailsText,actionPerformed: {useSourceNodeDetailsText=cb3.selected})&#xa;                separator()&#xa;                label(text: &apos;For the candidate node&apos;)&#xa;                checkBox(id: &apos;cba&apos;,text:&quot;Search words in CORE TEXT&quot;,selected: true,actionPerformed: {searchTargetNodeCoreText=true})&#xa;                checkBox(id: &apos;cbb&apos;,text:&quot;Search words in NOTE TEXT&quot;,selected: searchTargetNodeNoteText,actionPerformed: {searchTargetNodeNoteText=cbb.selected})&#xa;                checkBox(id: &apos;cbc&apos;,text:&quot;Search words in DETAILS TEXT&quot;,selected: searchTargetNodeDetailsText,actionPerformed: {searchTargetNodeDetailsText=cbc.selected})&#xa;            }&#xa;            hbox{&#xa;                button(action: action(name: &apos;Find Candidates&apos;, closure: {&#xa;                    if (input.text!=&quot;&quot;) {&#xa;                        useWords=true&#xa;                        useWordsText=input.text&#xa;                    }&#xa;                    connectoroptionsdialog.dispose()&#xa;                    connectorUI(newNode)&#xa;                }))&#xa;                button(action: action(name: &apos;Cancel&apos;, closure: {&#xa;                    connectoroptionsdialog.dispose()&#xa;                }))&#xa;            }&#xa;        }&#xa;    }&#xa;    connectoroptionsdialog.getContentPane().add(panel)&#xa;    connectoroptionsdialog.pack()&#xa;    connectoroptionsdialog.show()&#xa;}&#xa;&#xa;//-----------------------&#xa;// == UI FUNCTION: == Connector Candidates User Interface&#xa;// ============= Search for possible connections to the selected node based on   =============&#xa;// ============= &apos;proper&apos; words in the selected nodes core text                  =============&#xa;def connectorUI(newNode) {&#xa;&#xa;    // clear the working array that will contain any possible candidate nodes&#xa;    connection_candidates_nodes_data = []&#xa;&#xa;    // get the current nodes ID&#xa;    def currentNodeID=newNode.nodeID&#xa;&#xa;    // get &apos;proper&apos; words (ie not stopwords) from the current nodes core text&#xa;&#xa;    searchwords=&quot;&quot;&#xa;&#xa;    if (useWords) {&#xa;        searchwords=useWordsText.replace(&apos;,&apos;,&apos; &apos;)&#xa;    }&#xa;&#xa;    if (useSourceNodeCoreText) {&#xa;        searchwords+=&quot; &quot;+removeHtmlTags(newNode.text)&#xa;    }&#xa;&#xa;    if (useSourceNodeNoteText) {&#xa;        searchwords+=&quot; &quot;+removeHtmlTags(newNode.noteText)&#xa;    }&#xa;&#xa;    if (useSourceNodeDetailsText) {&#xa;        searchwords+=&quot; &quot;+removeHtmlTags(newNode.detailsText)&#xa;    }&#xa;&#xa;    searchwords=searchwords.replace(&quot;empty&quot;,&quot;&quot;)&#xa;&#xa;    currentnodewords=[]&#xa;&#xa;    def usePhrase=false&#xa;    def useRegex=false&#xa;&#xa;    if (useWordsText.startsWith(&apos;&quot;&apos;) &amp;&amp; useWordsText.endsWith(&apos;&quot;&apos;)) {&#xa;        // check if user wants to search for a specific phrase ie string surrounded with double quotes&#xa;        usePhrase=true&#xa;        currentnodewords.add(useWordsText.substring(1,useWordsText.length()-1)) // if searching for a phrase use the whole current node text(s)&#xa;    } else if (useWordsText.startsWith(&apos;/&apos;) &amp;&amp; useWordsText.endsWith(&apos;/&apos;)) {&#xa;        // check if user wants to search for a specific phrase ie string surrounded with double quotes&#xa;        useRegex=true&#xa;        currentnodewords.add(useWordsText.substring(1,useWordsText.length()-1)) // if searching for a phrase use the whole current node text(s)&#xa;    }&#xa;&#xa;    else {&#xa;        // otherwise use individual words in current node text(s)&#xa;        words=searchwords.split(&quot; &quot;)&#xa;        words.each {&#xa;            if (it!=&quot;&quot;) {&#xa;                cleanword=cleanupWord(it)&#xa;                if (!cleanword.equals(&quot;&quot;)) {&#xa;                    currentnodewords.add(cleanword)&#xa;                }&#xa;            }&#xa;        }&#xa;        currentnodewords=currentnodewords.unique()&#xa;        usePhrase=false&#xa;        useRegex=false&#xa;    }&#xa;&#xa;&#xa;    // English noise words to be ignored when looking for possible connection candidates&#xa;    def stopWords = [&quot;a&quot;, &quot;about&quot;, &quot;above&quot;, &quot;above&quot;, &quot;across&quot;, &quot;after&quot;, &quot;afterwards&quot;, &quot;again&quot;, &quot;against&quot;, &quot;all&quot;, &quot;almost&quot;, &quot;alone&quot;, &quot;along&quot;,&#xa;                     &quot;already&quot;, &quot;also&quot;, &quot;although&quot;, &quot;always&quot;, &quot;am&quot;, &quot;among&quot;, &quot;amongst&quot;, &quot;amoungst&quot;, &quot;amount&quot;, &quot;an&quot;, &quot;and&quot;, &quot;another&quot;, &quot;any&quot;,&#xa;                     &quot;anyhow&quot;, &quot;anyone&quot;, &quot;anything&quot;, &quot;anyway&quot;, &quot;anywhere&quot;, &quot;are&quot;, &quot;around&quot;, &quot;as&quot;, &quot;at&quot;, &quot;back&quot;, &quot;be&quot;, &quot;became&quot;, &quot;because&quot;,&#xa;                     &quot;become&quot;, &quot;becomes&quot;, &quot;becoming&quot;, &quot;been&quot;, &quot;before&quot;, &quot;beforehand&quot;, &quot;behind&quot;, &quot;being&quot;, &quot;below&quot;, &quot;beside&quot;, &quot;besides&quot;,&#xa;                     &quot;between&quot;, &quot;beyond&quot;, &quot;bill&quot;, &quot;both&quot;, &quot;bottom&quot;, &quot;but&quot;, &quot;by&quot;, &quot;call&quot;, &quot;can&quot;, &quot;cannot&quot;, &quot;cant&quot;, &quot;co&quot;, &quot;con&quot;, &quot;could&quot;,&#xa;                     &quot;couldnt&quot;, &quot;cry&quot;, &quot;de&quot;, &quot;describe&quot;, &quot;detail&quot;, &quot;do&quot;, &quot;done&quot;, &quot;down&quot;, &quot;due&quot;, &quot;during&quot;, &quot;each&quot;, &quot;eg&quot;, &quot;eight&quot;, &quot;either&quot;,&#xa;                     &quot;eleven&quot;, &quot;else&quot;, &quot;elsewhere&quot;, &quot;empty&quot;, &quot;enough&quot;, &quot;etc&quot;, &quot;even&quot;, &quot;ever&quot;, &quot;every&quot;, &quot;everyone&quot;, &quot;everything&quot;,&#xa;                     &quot;everywhere&quot;, &quot;except&quot;, &quot;few&quot;, &quot;fifteen&quot;, &quot;fify&quot;, &quot;fill&quot;, &quot;find&quot;, &quot;fire&quot;, &quot;first&quot;, &quot;five&quot;, &quot;for&quot;, &quot;former&quot;,&#xa;                     &quot;formerly&quot;, &quot;forty&quot;, &quot;found&quot;, &quot;four&quot;, &quot;from&quot;, &quot;front&quot;, &quot;full&quot;, &quot;further&quot;, &quot;get&quot;, &quot;give&quot;, &quot;go&quot;, &quot;had&quot;, &quot;has&quot;,&#xa;                     &quot;hasnt&quot;, &quot;have&quot;, &quot;he&quot;, &quot;hence&quot;, &quot;her&quot;, &quot;here&quot;, &quot;hereafter&quot;, &quot;hereby&quot;, &quot;herein&quot;, &quot;hereupon&quot;, &quot;hers&quot;, &quot;herself&quot;,&#xa;                     &quot;him&quot;, &quot;himself&quot;, &quot;his&quot;, &quot;how&quot;, &quot;however&quot;, &quot;hundred&quot;, &quot;i&quot;,&quot;ie&quot;, &quot;if&quot;, &quot;im&quot;, &quot;in&quot;, &quot;inc&quot;, &quot;indeed&quot;, &quot;interest&quot;, &quot;into&quot;,&#xa;                     &quot;is&quot;, &quot;it&quot;, &quot;its&quot;, &quot;itself&quot;, &quot;ive&quot;, &quot;keep&quot;, &quot;last&quot;, &quot;latter&quot;, &quot;latterly&quot;, &quot;least&quot;, &quot;less&quot;, &quot;ltd&quot;, &quot;made&quot;, &quot;many&quot;,&#xa;                     &quot;may&quot;, &quot;me&quot;, &quot;meanwhile&quot;, &quot;might&quot;, &quot;mill&quot;, &quot;mine&quot;, &quot;more&quot;, &quot;moreover&quot;, &quot;most&quot;, &quot;mostly&quot;, &quot;move&quot;, &quot;much&quot;, &quot;must&quot;,&#xa;                     &quot;my&quot;, &quot;myself&quot;, &quot;name&quot;, &quot;namely&quot;, &quot;neither&quot;, &quot;never&quot;, &quot;nevertheless&quot;, &quot;next&quot;, &quot;nine&quot;, &quot;no&quot;, &quot;nobody&quot;, &quot;none&quot;, &quot;noone&quot;,&#xa;                     &quot;nor&quot;, &quot;not&quot;, &quot;nothing&quot;, &quot;now&quot;, &quot;nowhere&quot;, &quot;of&quot;, &quot;off&quot;, &quot;often&quot;, &quot;on&quot;, &quot;once&quot;, &quot;one&quot;, &quot;only&quot;, &quot;onto&quot;, &quot;or&quot;, &quot;other&quot;,&#xa;                     &quot;others&quot;, &quot;otherwise&quot;, &quot;our&quot;, &quot;ours&quot;, &quot;ourselves&quot;, &quot;out&quot;, &quot;over&quot;, &quot;own&quot;, &quot;part&quot;, &quot;per&quot;, &quot;perhaps&quot;, &quot;please&quot;, &quot;put&quot;,&#xa;                     &quot;rather&quot;, &quot;re&quot;, &quot;same&quot;, &quot;see&quot;, &quot;seem&quot;, &quot;seemed&quot;, &quot;seeming&quot;, &quot;seems&quot;, &quot;serious&quot;, &quot;several&quot;, &quot;she&quot;, &quot;should&quot;, &quot;show&quot;,&#xa;                     &quot;side&quot;, &quot;since&quot;, &quot;sincere&quot;, &quot;six&quot;, &quot;sixty&quot;, &quot;so&quot;, &quot;some&quot;, &quot;somehow&quot;, &quot;someone&quot;, &quot;something&quot;, &quot;sometime&quot;, &quot;sometimes&quot;,&#xa;                     &quot;somewhere&quot;, &quot;still&quot;, &quot;such&quot;, &quot;system&quot;, &quot;take&quot;, &quot;ten&quot;, &quot;than&quot;, &quot;that&quot;, &quot;the&quot;, &quot;their&quot;, &quot;them&quot;, &quot;themselves&quot;, &quot;then&quot;,&#xa;                     &quot;thence&quot;, &quot;there&quot;, &quot;thereafter&quot;, &quot;thereby&quot;, &quot;therefore&quot;, &quot;therein&quot;, &quot;thereupon&quot;, &quot;these&quot;, &quot;they&quot;, &quot;theyve&quot;,&quot;thickv&quot;, &quot;thin&quot;,&#xa;                     &quot;third&quot;, &quot;this&quot;, &quot;those&quot;, &quot;though&quot;, &quot;three&quot;, &quot;through&quot;, &quot;throughout&quot;, &quot;thru&quot;, &quot;thus&quot;, &quot;to&quot;, &quot;together&quot;, &quot;too&quot;, &quot;top&quot;,&#xa;                     &quot;toward&quot;, &quot;towards&quot;, &quot;twelve&quot;, &quot;twenty&quot;, &quot;two&quot;, &quot;un&quot;, &quot;under&quot;, &quot;until&quot;, &quot;up&quot;, &quot;upon&quot;, &quot;us&quot;, &quot;very&quot;, &quot;via&quot;, &quot;was&quot;, &quot;we&quot;,&quot;weve&quot;,&#xa;                     &quot;well&quot;, &quot;were&quot;, &quot;what&quot;, &quot;whatever&quot;, &quot;when&quot;, &quot;whence&quot;, &quot;whenever&quot;, &quot;where&quot;, &quot;whereafter&quot;, &quot;whereas&quot;, &quot;whereby&quot;,&#xa;                     &quot;wherein&quot;, &quot;whereupon&quot;, &quot;wherever&quot;, &quot;whether&quot;, &quot;which&quot;, &quot;while&quot;, &quot;whither&quot;, &quot;who&quot;, &quot;whoever&quot;, &quot;whole&quot;, &quot;whom&quot;, &quot;whose&quot;,&#xa;                     &quot;why&quot;, &quot;will&quot;, &quot;with&quot;, &quot;within&quot;, &quot;without&quot;, &quot;would&quot;, &quot;yet&quot;, &quot;you&quot;, &quot;your&quot;, &quot;yours&quot;, &quot;yourself&quot;, &quot;yourselves&quot;,&quot;youve&quot;,&#xa;                     &quot;the&quot;,&quot;=&quot;,&quot;?&quot;,&quot;-&quot;]&#xa;&#xa;    // search through all nodes&#xa;    c.findAllDepthFirst().each {&#xa;        candidatenode=it&#xa;&#xa;        // only search if candidate node is not the current node&#xa;        if (currentNodeID != candidatenode.nodeID) {&#xa;&#xa;            // strip any html tags in core  text&#xa;            candidatetext=removeHtmlTags(candidatenode.text)&#xa;&#xa;            // strip any html tags in note text&#xa;            if (searchTargetNodeNoteText) {&#xa;                candidatetext+=&quot; &quot;+removeHtmlTags(candidatenode.noteText)&#xa;            }&#xa;&#xa;            // strip any html tags in details text&#xa;            if (searchTargetNodeDetailsText) {&#xa;                candidatetext+=&quot; &quot;+removeHtmlTags(candidatenode.detailsText)&#xa;            }&#xa;&#xa;            candidatenodewords=[]&#xa;            if (usePhrase || useRegex) {&#xa;                // if only searching for a Phrase or Regex strip lead and trail double quote&#xa;                // and put into candidate node words array&#xa;                candidatenodewords.add(candidatetext)&#xa;            } else {&#xa;                // load proper words into candidate node words array&#xa;                words=candidatetext.split(&quot; &quot;)&#xa;                words.each {&#xa;                    cleanword=cleanupWord(it)&#xa;                    if (!cleanword.equals(&quot;&quot;)) {&#xa;                        candidatenodewords.add(cleanword)&#xa;                    }&#xa;                }&#xa;                candidatenodewords=candidatenodewords.unique()&#xa;            }&#xa;&#xa;&#xa;            // process each proper word in the selected nodes text&#xa;            currentnodewords.each {&#xa;&#xa;                currentnodeword=it&#xa;&#xa;                if (currentnodeword != &quot;&quot;) {&#xa;&#xa;                    // check if word is a proper word ie NOT a noise (stop) word eg the, of, and etcs&#xa;                    if (!stopWords.contains(currentnodeword)) {&#xa;&#xa;                        def found=false&#xa;&#xa;                        if (usePhrase) {&#xa;                            // if searching a a phrase look for phrase in candidate node text(s)&#xa;                            if (candidatetext.contains(currentnodeword)) {&#xa;                                found=true&#xa;                            }&#xa;                        } else if (useRegex) {&#xa;                            // if searching by regular expression look for pattern anywhere in the candidate text&#xa;                            if (candidatetext =~ currentnodeword) {&#xa;                                found=true&#xa;                            }&#xa;                        }&#xa;&#xa;                        else {&#xa;                            // have proper word, check if it is in the candidate nodes individual words&#xa;                            if (candidatenodewords.contains(currentnodeword)) {&#xa;                                found = true&#xa;                            }&#xa;                        }&#xa;                        if (found) {&#xa;&#xa;                            // make sure we haven&apos;t already grabbed this candidate node&#xa;//                            if (nodeIDNotInCurrentTables(candidatenode.nodeID)) {&#xa;&#xa;                            // get parents node text&#xa;&#xa;                            if (candidatenode.parent != null) {&#xa;                                parentnodetext = candidatenode.parent.text&#xa;                            } else {&#xa;                                parentnodetext=&apos;root&apos;&#xa;                            }&#xa;&#xa;                            // add the candidate node to the working array&#xa;                            connection_candidates_nodes_data.add([id: candidatenode.nodeID,&#xa;                                                                  type: &apos;conn?&apos;,&#xa;                                                                  nodetext: formatNodeTextForCell(candidatenode.text),&#xa;                                                                  label: &apos;&apos;,&#xa;                                                                  notetext: candidatenode.noteText,&#xa;                                                                  details: candidatenode.detailsText,&#xa;                                                                  properword: currentnodeword.toString().toUpperCase(),&#xa;                                                                  parent: parentnodetext])&#xa;//                            }&#xa;                        }&#xa;                    }&#xa;                }&#xa;            }&#xa;        }&#xa;    }&#xa;&#xa;    // sort connection_candidates_nodes_data in word,node text order&#xa;    if (!usePhrase &amp;&amp; !useRegex) {&#xa;        connection_candidates_nodes_data.sort { it.properword + it.nodetext }&#xa;    }&#xa;&#xa;    // define the connector candidates UI&#xa;    // which is a list of candidate nodes&#xa;    connectorcandidatesframe = swing.dialog(&#xa;            title: &quot;Connection Candidates&quot;,&#xa;            defaultCloseOperation: JFrame.DISPOSE_ON_CLOSE,&#xa;            alwaysOnTop: true,&#xa;            modal: false,&#xa;            location: [mypanel.getAt(&apos;width&apos;)+5,0]&#xa;    ) {&#xa;&#xa;        // connector panel&#xa;        connectorpanel = panel(background: Color.WHITE) {&#xa;            gridLayout()&#xa;            vbox {&#xa;                connectorContainer = vbox {&#xa;&#xa;                    // Possible connection candidate node details in table (note using customised table renderer ConnectorCandidateTableCellRenderer)&#xa;                    vbox {&#xa;                        panel() {&#xa;                            label(text: &quot;Possible Connections&quot;, foreground: Color.GRAY)&#xa;                        }&#xa;                        panel() {&#xa;                            borderLayout()&#xa;                            vbox {&#xa;                                scrollPane {&#xa;                                    connectionCandidatesTable = table(background: Color.WHITE, showGrid: false, gridColor: Color.GRAY, autoCreateRowSorter: true) {&#xa;                                        editing: true;&#xa;                                        model = tableModel(list: connection_candidates_nodes_data) {&#xa;//                                            propertyColumn(header: &apos;ID&apos;, propertyName: &apos;id&apos;, editable: false, cellRenderer: new ConnectorCandidateTableCellRenderer(), minWidth: 50);&#xa;                                            propertyColumn(header: &apos;Word&apos;, propertyName: &apos;properword&apos;, editable: false, cellRenderer: new ConnectorCandidateTableCellRenderer(), minWidth: 50);&#xa;                                            propertyColumn(header: &apos;Type&apos;, propertyName: &apos;type&apos;, editable: false, cellRenderer: new ConnectorCandidateTableCellRenderer());&#xa;                                            propertyColumn(header: &apos;Node&apos;, propertyName: &apos;nodetext&apos;, editable: false, cellRenderer: new ConnectorCandidateTableCellRenderer(), minWidth: 250);&#xa;                                            propertyColumn(header: &apos;Note&apos;, propertyName: &apos;notetext&apos;, editable: false, cellRenderer: new ConnectorCandidateTableCellRenderer());&#xa;                                            propertyColumn(header: &apos;Details&apos;, propertyName: &apos;details&apos;, editable: false, cellRenderer: new ConnectorCandidateTableCellRenderer());&#xa;                                            propertyColumn(header: &apos;Parent&apos;, propertyName: &apos;parent&apos;, editable: false, cellRenderer: new ConnectorCandidateTableCellRenderer());&#xa;                                        }&#xa;                                    }&#xa;                                }&#xa;                            }&#xa;                        }&#xa;                    }&#xa;                }&#xa;                vbox {&#xa;                    hbox {&#xa;                        button(action: action(name: &apos;Locate&apos;, defaultButton: true,&#xa;                                closure: {&#xa;                                    // locate the selected candidate node and go to it in the map&#xa;                                    // but do not load it into Map Walker&#xa;                                    if (selectedCandidateNode != null) {&#xa;                                        c.find {&#xa;                                            it.text == selectedCandidateNode.text&#xa;                                        }.each {&#xa;                                            selectNodeByTitle(it.text)&#xa;                                            updateRecentNodesVisited(it.text)&#xa;                                        }&#xa;                                    }&#xa;                                }))&#xa;                        button(action: action(name: &apos;Go To&apos;, defaultButton: true,&#xa;                                closure: {&#xa;                                    // locate the selected candidate node and go to it in the map&#xa;                                    // and also load it into Map Walkers array&#xa;                                    if (selectedCandidateNode != null) {&#xa;                                        c.find {&#xa;                                            it.text == selectedCandidateNode.text&#xa;                                        }.each {&#xa;                                            selectNodeByTitle(it.text)&#xa;                                            newNode = c.selected&#xa;                                            loadNodeData(newNode)&#xa;                                            updateUI(newNode)&#xa;                                            selectedCandidateNode = null&#xa;                                            connectionCandidatesDisplayed = false&#xa;                                            connectorcandidatesframe.dispose()&#xa;                                        }&#xa;                                    }&#xa;                                }))&#xa;                        button(action: action(name: &apos;Close&apos;, closure: {&#xa;                            connectionCandidatesDisplayed = false&#xa;                            connectorcandidatesframe.dispose()&#xa;                        }))&#xa;                    }&#xa;                    hbox {&#xa;                        button(action: action(name: &apos;Connect ALL&apos;, defaultButton: true,&#xa;                                closure: {&#xa;                                    // Make connectors for ALL the suggested candidates and&#xa;                                    // use the linking word as the connector label&#xa;&#xa;                                    // get current node selected&#xa;                                    def sourcenode = newNode&#xa;&#xa;                                    // for each suggested candidate add a connector&#xa;                                    connection_candidates_nodes_data.findAll().each {&#xa;                                        def newconnector = sourcenode.addConnectorTo(getNodeByID(it[&apos;id&apos;]))&#xa;                                        newconnector.setMiddleLabel(it[&apos;properword&apos;].toLowerCase())&#xa;                                        newconnector.setStartArrow(false)&#xa;                                        newconnector.setEndArrow(true)&#xa;                                    }&#xa;                                }))&#xa;                        button(action: action(name: &apos;Undo &quot;Connect ALL&quot;&apos;, defaultButton: true,&#xa;                                closure: {&#xa;                                    c.undo()&#xa;                                }))&#xa;                        button(action: action(name: &apos;Save as New Map&apos;, defaultButton: true,&#xa;                                closure: {&#xa;                                    // export the source node and every possible node to&#xa;                                    // a new map with connectors&#xa;&#xa;                                    // get current node selected&#xa;                                    def sourcenode = newNode&#xa;&#xa;                                    // get current timestamp&#xa;                                    def date = new Date()&#xa;                                    sdf = new SimpleDateFormat(&quot;yyyy.MM.dd HH:mm:ss&quot;)&#xa;&#xa;                                    // for each candidate get the target node to export&#xa;                                    def exportnodes=[]&#xa;&#xa;                                    tabledata=&quot;&lt;TR&gt;&lt;TD&gt;&lt;b&gt;Word&lt;/b&gt;&lt;/TD&gt;&lt;TD&gt;&lt;b&gt;Candidate&lt;/b&gt;&lt;/TD&gt;&lt;/TR&gt;&quot;&#xa;&#xa;                                    connection_candidates_nodes_data.findAll().each {&#xa;                                        exportnode=getNodeByID(it[&quot;id&quot;])&#xa;                                        if (exportnode!=null) {&#xa;                                            tabledata += &quot;&lt;TR&gt;&lt;TD&gt;${it[&quot;properword&quot;]}&lt;/TD&gt;&lt;TD&gt;${it[&quot;nodetext&quot;]}&lt;/TD&gt;&lt;/TR&gt;&quot;&#xa;                                            exportnodes.add([getNodeByID(it[&quot;id&quot;]),it])&#xa;                                        }&#xa;                                    }&#xa;                                    htmlstring=&quot;&quot;&quot;&#xa;                                                &lt;H3&gt;Connector Candidates ${sdf.format(date)}&lt;/H3&gt;&#xa;                                                &lt;TABLE border=&quot;1&quot;&gt;&#xa;                                                    $tabledata&#xa;                                                &lt;/TABLE&gt;&#xa;                                               &quot;&quot;&quot;&#xa;                                    // create a new map&#xa;                                    def newMap = c.newMap()&#xa;&#xa;                                    // copy current node to the root node of the new map&#xa;                                    copyProperties(newMap.root,sourcenode)&#xa;&#xa;&#xa;&#xa;                                    // create a read me node with details of the possible candidates&#xa;                                    def readmenode = newMap.root.createChild()&#xa;                                    readmenode.text=&quot;READ ME&quot;&#xa;                                    readmenode.noteText=htmlstring&#xa;&#xa;&#xa;                                    // export candidate nodes to the new map as children of the root node&#xa;                                    exportnodes.each{&#xa;&#xa;                                        // create new node&#xa;                                        def newnode = newMap.root.createChild()&#xa;&#xa;                                        // copy details from candidate node&#xa;                                        copyProperties(newnode, it[0])&#xa;&#xa;                                        // add connector from cnadidate node back to root node with&#xa;                                        // label that &apos;made the connection&apos;&#xa;                                        def newconnector=newnode.addConnectorTo(newMap.root)&#xa;                                        newconnector.setMiddleLabel(it[1][&quot;properword&quot;])&#xa;                                        newconnector.setStartArrow(false)&#xa;                                        newconnector.setEndArrow(true)&#xa;                                    }&#xa;&#xa;                                }))&#xa;                    }&#xa;                }&#xa;            }&#xa;        }&#xa;    }&#xa;&#xa;    // prevent some columns in the underlying table model from displaying in the connector candidates UI&#xa;    HideTableColumns(connectionCandidatesTable,[&apos;type&apos;,&apos;notetext&apos;,&apos;details&apos;,&apos;label&apos;, &apos;parent&apos;])&#xa;&#xa;&#xa;    // Mouse listener for the connector candidates UI&#xa;    connectionCandidatesTable.addMouseListener(&#xa;            new MouseAdapter() {&#xa;&#xa;                // ensure we can reference the global scope&#xa;                def globalscope=this.this$0&#xa;&#xa;                // Trick to get Tooltip for cell to stay visible long enough to read&#xa;                final int defaultDismissTimeout = ToolTipManager.sharedInstance().getDismissDelay();&#xa;                final int dismissDelayMinutes = (int) TimeUnit.MINUTES.toMillis(100); // 10 minutes&#xa;                public void mouseEntered(MouseEvent event) {&#xa;                    ToolTipManager.sharedInstance().setDismissDelay(dismissDelayMinutes);&#xa;                }&#xa;                public void mouseExited(MouseEvent event) {&#xa;                    ToolTipManager.sharedInstance().setDismissDelay(defaultDismissTimeout);&#xa;                }&#xa;&#xa;                // Take action on mouse click&#xa;                public void mousePressed(MouseEvent event) {&#xa;&#xa;                    if ((event.getModifiers() &amp; InputEvent.BUTTON1_MASK) != 0) {&#xa;&#xa;                        // ---- Left Click&#xa;&#xa;                        // get node that has been selected as a candidate&#xa;                        def selectedcandidatenodedata=globalscope.connection_candidates_nodes_data[event.getSource().getSelectedRow()]&#xa;                        globalscope.selectedCandidateNode=findNodeByID(selectedcandidatenodedata[&quot;id&quot;])&#xa;&#xa;                        // on double click load the node into Map Insight as the main node in focus&#xa;                        if (event.getClickCount()==2) {&#xa;                            displayNewNode(event.component,globalscope.connection_candidates_nodes_data)&#xa;                            globalscope.connectorcandidatesframe.dispose()&#xa;                        }&#xa;                    }else if ((event.getModifiers() &amp; InputEvent.BUTTON3_MASK) != 0) {&#xa;&#xa;                        // ---- Right Click&#xa;&#xa;                        // display dialog to create a connector from the Map Insight focussed node to the candidate node&#xa;&#xa;                        def sourcenode=globalscope.newNode&#xa;&#xa;                        def targetnodedata=globalscope.connection_candidates_nodes_data[event.getSource().getSelectedRow()]&#xa;                        def targetnode=getNodeByID(targetnodedata[&quot;id&quot;])&#xa;&#xa;                        // Create Connector UI&#xa;&#xa;                        def swing = new SwingBuilder()&#xa;                        def middlelabel=&quot;&quot;&#xa;                        def createconnectordialog = swing.dialog(title:&apos;Create Connector&apos;,&#xa;                                id:&apos;createConnectorDialog&apos;,&#xa;                                minimumSize: [300,50],&#xa;                                modal:true,&#xa;                                alwaysOnTop: true,&#xa;                                owner:globalscope.connectorcandidatesframe,&#xa;                                defaultCloseOperation:JFrame.DO_NOTHING_ON_CLOSE,&#xa;                                //                    Using DO_NOTHING_ON_CLOSE so the Close button has full control&#xa;                                //                    and it can ensure only one instance of the dialog appears&#xa;                                pack:true,&#xa;                                show:true) {&#xa;                            panel() {&#xa;                                boxLayout(axis: BoxLayout.Y_AXIS)&#xa;                                vbox {&#xa;                                    panel() {&#xa;                                        flowLayout()&#xa;                                        vbox {&#xa;                                            //                                        gridLayout(columns: 1, rows: 8)&#xa;                                            label(text: &apos;Create connector from&apos;, horizontalAlignment: JLabel.CENTER)&#xa;                                            label(text: &quot;$sourcenode.text&quot;, horizontalAlignment: JLabel.CENTER, foreground: Color.BLUE)&#xa;                                            label(text: &quot;to&quot;, horizontalAlignment: JLabel.CENTER)&#xa;                                            label(text: &quot;$targetnode.text&quot;, horizontalAlignment: JLabel.CENTER, foreground: Color.BLUE)&#xa;                                            separator()&#xa;                                            label(text: &quot;Enter new connector middle label &quot;, horizontalAlignment: JLabel.CENTER)&#xa;                                            scrollPane() {&#xa;                                                def input = textArea(columns: 20, rows: 3, text: targetnodedata[&apos;properword&apos;].toLowerCase())&#xa;                                                input.addFocusListener(&#xa;                                                        [focusGained: {},&#xa;                                                         focusLost  : {&#xa;                                                             middlelabel = input.text&#xa;                                                         }] as FocusListener)&#xa;                                            }&#xa;                                        }&#xa;                                    }&#xa;                                    hbox {&#xa;                                        button(action: action(name: &apos;Add Connector&apos;, closure: {&#xa;                                            def newconnector = sourcenode.addConnectorTo(targetnode)&#xa;                                            newconnector.setMiddleLabel(middlelabel.toLowerCase())&#xa;//                                            newconnector.setStartArrow(false)&#xa;                                            newconnector.setEndArrow(true)&#xa;                                            dispose()&#xa;                                        }))&#xa;                                        button(action: action(name: &apos;Close&apos;, closure: {&#xa;                                            dispose()&#xa;                                        }))&#xa;                                    }&#xa;                                }&#xa;                            }&#xa;                        }&#xa;                    }&#xa;&#xa;                    // double mouse click&#xa;&#xa;                    else if (event.getClickCount()==2) {&#xa;                        // do nothing on double click&#xa;                    }&#xa;                }&#xa;            }&#xa;    )&#xa;&#xa;    connectorcandidatesframe.pack()&#xa;    connectorcandidatesframe.show()&#xa;&#xa;}&#xa;&#xa;//****************************************************&#xa;// UI - class overrides the connector candidate table&#xa;// cell renderer in the Connector Candidates View&#xa;//****************************************************&#xa;&#xa;class ConnectorCandidateTableCellRenderer extends JLabel implements TableCellRenderer {&#xa;    public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected,&#xa;                                                   boolean hasFocus, int rowIndex, int vColIndex) {&#xa;&#xa;        setText(removeHtmlTags(value.toString()))&#xa;&#xa;        // center the text in the cell&#xa;        setHorizontalAlignment(SwingConstants.LEFT)&#xa;&#xa;        // color the cell based on whether the refered node is&#xa;        // a parent of the selected node&#xa;        // a child of the selected node&#xa;        // a connection into or out of the selected node&#xa;&#xa;        if (isSelected)&#xa;        {&#xa;            setBackground(Color.GRAY);&#xa;            setForeground(Color.BLUE);&#xa;        }&#xa;        else&#xa;        {&#xa;            setBackground(table.getBackground());&#xa;            setForeground(table.getForeground());&#xa;        }&#xa;&#xa;        if (vColIndex==0) {&#xa;            setForeground(Color.RED)&#xa;        }&#xa;&#xa;        // Get the current model row from the table (this works even when the table columns are sorted)&#xa;        def modelRow = table.convertRowIndexToModel(rowIndex)&#xa;&#xa;        // Set up tooltip for cell which shows the note and detail texts related to the node the cell refers to&#xa;        def searchword=table.model.getValueAt(modelRow,0)&#xa;        String nodetype=removeHtmlTags(value.toString())+&quot;&lt;HR&gt;Connected via word -&gt; &quot;+searchword+&apos;&lt;HR&gt;&apos;&#xa;        String notetext=table.model.getValueAt(modelRow,3)&#xa;        if (notetext==null) notetext=&quot;empty&quot;&#xa;        String detailstext=table.model.getValueAt(modelRow,4)&#xa;        String parentnodetext=table.model.getValueAt(modelRow,5)&#xa;        if (detailstext==null) detailstext=&quot;empty&quot;&#xa;&#xa;        // format tooltip text for display&#xa;        def tooltiptext=formatForSwingDisplay(nodetype,value,notetext,detailstext).replace(&apos;&lt;/body&gt;&lt;/HTML&gt;&apos;,&apos;&apos;)+&apos;&lt;hr&gt;&lt;i&gt;Parent is &apos;+ parentnodetext+&apos;&lt;/i&gt;&lt;/body&gt;&lt;/HTML&gt;&apos;&#xa;        // and highlight the searched word in red (lower case, upper case and first letter capitalised&#xa;        if (searchword.trim().length()&gt;2) {&#xa;            tooltiptext=tooltiptext.replace(searchword.toLowerCase(),&apos;&lt;font color=&quot;RED&quot;&gt;&apos;+searchword.toLowerCase()+&apos;&lt;/font&gt;&apos;)&#xa;            tooltiptext=tooltiptext.replace(searchword.toUpperCase(),&apos;&lt;font color=&quot;RED&quot;&gt;&apos;+searchword.toUpperCase()+&apos;&lt;/font&gt;&apos;)&#xa;            tooltiptext=tooltiptext.replace(searchword[0].toUpperCase() + searchword[1..-1].toLowerCase()&#xa;                    ,&apos;&lt;font color=&quot;RED&quot;&gt;&apos;+searchword[0].toUpperCase() + searchword[1..-1].toLowerCase()+&apos;&lt;/font&gt;&apos;)&#xa;        }&#xa;        setToolTipText((String) tooltiptext)&#xa;&#xa;&#xa;        return this&#xa;    }&#xa;}&#xa;&#xa;//*************************************************&#xa;// UI - Mouse Listeners for Map Insight Main Window&#xa;//*************************************************&#xa;&#xa;connectorsInTable.addMouseListener(&#xa;        new MouseAdapter() {&#xa;&#xa;            // global scope&#xa;            def globalscope=this.this$0&#xa;&#xa;            // Trick to get Tooltip for cell to stay visible long enough to read&#xa;            final int defaultDismissTimeout = ToolTipManager.sharedInstance().getDismissDelay();&#xa;            final int dismissDelayMinutes = (int) TimeUnit.MINUTES.toMillis(100); // 10 minutes&#xa;            public void mouseEntered(MouseEvent event) {&#xa;                ToolTipManager.sharedInstance().setDismissDelay(dismissDelayMinutes);&#xa;            }&#xa;            public void mouseExited(MouseEvent event) {&#xa;                ToolTipManager.sharedInstance().setDismissDelay(defaultDismissTimeout);&#xa;            }&#xa;&#xa;            // Take action on mouse click&#xa;            public void mouseClicked(MouseEvent event) {&#xa;                if (event.getClickCount()==2) {&#xa;                    displayNewNode(event.component,globalscope.nodes_data.findAll{it.type==&quot;conn-IN&quot;})&#xa;                    // note. the reference to this.this$0 is the only way I could find to get at the&#xa;                    // working arrays in the script level variables. There is probably a much&#xa;                    // easier way to do this.&#xa;                }&#xa;            }&#xa;        }&#xa;)&#xa;&#xa;parentTable.addMouseListener(&#xa;        new MouseAdapter() {&#xa;&#xa;            // global scope&#xa;            def globalscope=this.this$0&#xa;&#xa;            // Trick to get Tooltip for cell to stay visible long enough to read&#xa;            final int defaultDismissTimeout = ToolTipManager.sharedInstance().getDismissDelay();&#xa;            final int dismissDelayMinutes = (int) TimeUnit.MINUTES.toMillis(100); // 10 minutes&#xa;            public void mouseEntered(MouseEvent event) {&#xa;                ToolTipManager.sharedInstance().setDismissDelay(dismissDelayMinutes);&#xa;            }&#xa;            public void mouseExited(MouseEvent event) {&#xa;                ToolTipManager.sharedInstance().setDismissDelay(defaultDismissTimeout);&#xa;            }&#xa;&#xa;            // Take action on mouse click&#xa;            public void mouseClicked(MouseEvent event) {&#xa;                if (event.getClickCount()==2) {&#xa;                    displayNewNode(event.component,globalscope.nodes_data.findAll{it.type==&quot;parent&quot;})&#xa;                }&#xa;            }&#xa;        }&#xa;)&#xa;&#xa;childrenTable.addMouseListener(&#xa;        new MouseAdapter() {&#xa;&#xa;            // global scope&#xa;            def globalscope=this.this$0&#xa;&#xa;            // Trick to get Tooltip for cell to stay visible long enough to read&#xa;            final int defaultDismissTimeout = ToolTipManager.sharedInstance().getDismissDelay();&#xa;            final int dismissDelayMinutes = (int) TimeUnit.MINUTES.toMillis(100); // 10 minutes&#xa;            public void mouseEntered(MouseEvent event) {&#xa;                ToolTipManager.sharedInstance().setDismissDelay(dismissDelayMinutes);&#xa;            }&#xa;            public void mouseExited(MouseEvent event) {&#xa;                ToolTipManager.sharedInstance().setDismissDelay(defaultDismissTimeout);&#xa;            }&#xa;&#xa;            // Take action on mouse click&#xa;            public void mouseClicked(MouseEvent event) {&#xa;                if (event.getClickCount() == 2) {&#xa;                    displayNewNode(event.component, globalscope.nodes_data.findAll{it.type==&quot;child&quot;})&#xa;                }&#xa;            }&#xa;        }&#xa;)&#xa;&#xa;connectorsOutTable.addMouseListener(&#xa;        new MouseAdapter() {&#xa;&#xa;            // global scope&#xa;            def globalscope=this.this$0&#xa;&#xa;            // Trick to get Tooltip for cell to stay visible long enough to read&#xa;            final int defaultDismissTimeout = ToolTipManager.sharedInstance().getDismissDelay();&#xa;            final int dismissDelayMinutes = (int) TimeUnit.MINUTES.toMillis(100); // 10 minutes&#xa;            public void mouseEntered(MouseEvent event) {&#xa;                ToolTipManager.sharedInstance().setDismissDelay(dismissDelayMinutes);&#xa;            }&#xa;            public void mouseExited(MouseEvent event) {&#xa;                ToolTipManager.sharedInstance().setDismissDelay(defaultDismissTimeout);&#xa;            }&#xa;&#xa;            // Take action on mouse click&#xa;            public void mouseClicked(MouseEvent event) {&#xa;                if (event.getClickCount()==2) {&#xa;                    displayNewNode(event.component,globalscope.nodes_data.findAll{it.type==&quot;conn-OUT&quot;})&#xa;                }&#xa;            }&#xa;        }&#xa;)&#xa;&#xa;//*********************************************&#xa;//         UI - Connector Manager Window&#xa;//*********************************************&#xa;def connectorManagerUI() {&#xa;    // ============= Manage all connectors in the map   =============&#xa;&#xa;    def selectedconnectorobject=null&#xa;&#xa;    // clear working array&#xa;    connectors_data = []&#xa;&#xa;    // search through all nodes for connectors out&#xa;    node.map.root.findAll().each {&#xa;        def theNodeID = it.nodeID&#xa;&#xa;        // retrieve each connector OUT from the node&#xa;        it.connectorsOut.each {&#xa;            it.setColor(Color.GRAY)&#xa;            def middlelabel = it.middleLabel&#xa;            sourceNode = getNodeByID(theNodeID)&#xa;            targetNode = getNodeByID(it.delegate.target.id)&#xa;            connectors_data.add([type       : &apos;conn-OUT&apos;,&#xa;                                 sourceID: sourceNode.id,&#xa;                                 sourcenodetext: formatNodeTextForCell(sourceNode.text),&#xa;                                 middlelabel: middlelabel,&#xa;                                 targetnodetext: formatNodeTextForCell(targetNode.text)])&#xa;        }&#xa;    }&#xa;&#xa;    connectorsframe = swing.dialog(&#xa;            title: &quot;Connectors&quot;,&#xa;            defaultCloseOperation: JFrame.DISPOSE_ON_CLOSE,&#xa;            alwaysOnTop: true,&#xa;            modal: false,&#xa;            location: [mypanel.getAt(&apos;width&apos;) + 5, 0]&#xa;    ) {&#xa;&#xa;        // connector panel&#xa;        connectorspanel = panel(background: Color.WHITE) {&#xa;            gridLayout()&#xa;            vbox {&#xa;&#xa;                connectorsContainer = vbox {&#xa;                    vbox {&#xa;                        panel() {&#xa;                            label(text: &quot;Manage All Connectors&quot;, foreground: Color.GRAY)&#xa;                        }&#xa;                        panel() {&#xa;                            borderLayout()&#xa;                            vbox {&#xa;                                scrollPane {&#xa;                                    connectorsTable = table(background: Color.WHITE, showGrid: false, gridColor: Color.GRAY,autoCreateRowSorter: true) {&#xa;                                        editing: true;&#xa;                                        model = tableModel(list: connectors_data) {&#xa;                                            propertyColumn(header: &apos;Source Node&apos;, propertyName: &apos;sourcenodetext&apos;, editable: false, cellRenderer: new ConnectorsTableCellRenderer(), minWidth: 100);&#xa;                                            propertyColumn(header: &apos;Middle Label&apos;, propertyName: &apos;middlelabel&apos;, editable: false, cellRenderer: new ConnectorsTableCellRenderer(), minWidth: 100);&#xa;                                            propertyColumn(header: &apos;Target Node&apos;, propertyName: &apos;targetnodetext&apos;, editable: false, cellRenderer: new ConnectorsTableCellRenderer(), minWidth: 100);&#xa;&#xa;                                        }&#xa;                                    }&#xa;                                }&#xa;                            }&#xa;                        }&#xa;&#xa;                        panel() {&#xa;                            panel(alignmentX: 0f) {&#xa;                                flowLayout(alignment: FlowLayout.RIGHT)&#xa;                                vbox {&#xa;                                    hbox {&#xa;                                        editconnectorbutton = button(action: action(name: &apos;Edit Label&apos;, defaultButton: true, enabled: false,&#xa;                                                closure: {&#xa;                                                    def sourcenode = getNodeByID(selectedconnectorobject.delegate.source.id)&#xa;                                                    def targetnode = getNodeByID(selectedconnectorobject.delegate.targetID)&#xa;&#xa;&#xa;                                                    def sourcenodetext = sourcenode.text&#xa;                                                    def targetnodetext = targetnode.text&#xa;                                                    def middlelabel = selectedconnectorobject.delegate.middleLabel&#xa;&#xa;                                                    editlabeldialog = swing.dialog(&#xa;                                                            title: &quot;Change Connector Label&quot;,&#xa;                                                            defaultCloseOperation: JFrame.DISPOSE_ON_CLOSE,&#xa;                                                            alwaysOnTop: true,&#xa;                                                            modal: false,&#xa;                                                            location: [mypanel.getAt(&apos;width&apos;) + connectorspanel.getAt(&apos;width&apos;) + 5, 0]&#xa;                                                    )&#xa;                                                    def panel = swing.panel {&#xa;                                                        vbox {&#xa;                                                            label(text: &quot;Enter new connector label&quot;)&#xa;                                                            input = textField(columns: 20, text: middlelabel)&#xa;                                                        }&#xa;                                                        hbox {&#xa;                                                            button(action: action(name: &apos;OK&apos;, closure: {&#xa;&#xa;                                                                if (input.text != &quot;&quot;) {&#xa;                                                                    selectedconnectorobject.delegate.middleLabel = input.text&#xa;                                                                    selectedconnectorobject.setColor(Color.GRAY)&#xa;                                                                }&#xa;&#xa;                                                                editlabeldialog.dispose()&#xa;                                                                connectorsframe.dispose()&#xa;                                                            }))&#xa;                                                            button(action: action(name: &apos;Cancel&apos;, closure: {&#xa;                                                                editlabeldialog.dispose()&#xa;                                                            }))&#xa;                                                        }&#xa;                                                    }&#xa;                                                    editlabeldialog.getContentPane().add(panel)&#xa;                                                    editlabeldialog.pack()&#xa;                                                    editlabeldialog.show()&#xa;                                                }))&#xa;                                        removeconnectorbutton = button(action: action(name: &apos;Remove Connector&apos;, defaultButton: true, enabled: false,&#xa;                                                closure: {&#xa;                                                    // Remove connector UI dialog&#xa;&#xa;&#xa;                                                    def sourcenode = getNodeByID(selectedconnectorobject.delegate.source.id)&#xa;                                                    def targetnode = getNodeByID(selectedconnectorobject.delegate.targetID)&#xa;&#xa;&#xa;                                                    def sourcenodetext = sourcenode.text&#xa;                                                    def targetnodetext = targetnode.text&#xa;                                                    def middlelabel = selectedconnectorobject.delegate.middleLabel&#xa;&#xa;                                                    //                                            def swing = new SwingBuilder()&#xa;                                                    removeconnectordialog = swing.dialog(title: &apos;Remove Connector&apos;,&#xa;                                                            id: &apos;removeConnectorDialog&apos;,&#xa;                                                            minimumSize: [100, 50],&#xa;                                                            modal: false,&#xa;                                                            alwaysOnTop: true,&#xa;                                                            defaultCloseOperation: JFrame.DO_NOTHING_ON_CLOSE,&#xa;                                                            //                    Using DO_NOTHING_ON_CLOSE so the Close button has full control&#xa;                                                            //                    and it can ensure only one instance of the dialog appears&#xa;                                                            pack: true,&#xa;                                                            show: true) {&#xa;                                                        panel() {&#xa;                                                            boxLayout(axis: BoxLayout.Y_AXIS)&#xa;                                                            panel() {&#xa;                                                                gridLayout(columns: 1, rows: 8)&#xa;                                                                label(text: &apos;Remove this connector?&apos;, horizontalAlignment: JLabel.CENTER)&#xa;                                                                label(text: &quot;&quot;)&#xa;                                                                label(text: &quot;from: $sourcenodetext&quot;, horizontalAlignment: JLabel.CENTER, foreground: Color.BLUE)&#xa;                                                                label(text: &quot;&quot;)&#xa;                                                                label(text: &quot;label: $middlelabel&quot;, horizontalAlignment: JLabel.CENTER)&#xa;                                                                label(text: &quot;&quot;)&#xa;                                                                label(text: &quot;to: $targetnodetext&quot;, horizontalAlignment: JLabel.CENTER, foreground: Color.BLUE)&#xa;                                                            }&#xa;                                                            panel() {&#xa;                                                                hbox {&#xa;                                                                    button(action: action(name: &apos;Remove Connector&apos;, closure: {&#xa;                                                                        //locate connectorOut within the node&#xa;                                                                        sourcenode.connectorsOut.each {&#xa;                                                                            def targetNode = getNodeByID(it.delegate.target.id)&#xa;                                                                            if (targetNode.text.equals(targetnodetext) &amp;&amp;&#xa;                                                                                    sourcenode.text.equals(sourcenodetext) &amp;&amp;&#xa;                                                                                    middlelabel.equals(it.delegate.middleLabel)) {&#xa;                                                                                sourcenode.removeConnector(it)&#xa;                                                                            }&#xa;                                                                        }&#xa;                                                                        removeconnectordialog.dispose()&#xa;                                                                        connectorsframe.dispose()&#xa;                                                                    }))&#xa;                                                                    button(action: action(name: &apos;Cancel&apos;, closure: {&#xa;                                                                        removeconnectordialog.dispose()&#xa;                                                                    }))&#xa;                                                                }&#xa;                                                            }&#xa;                                                        }&#xa;                                                    }&#xa;&#xa;                                                }))&#xa;                                        button(action: action(name: &apos;Close&apos;, closure: {&#xa;                                            connectorsDisplayed = false&#xa;                                            connectorsframe.dispose()&#xa;                                        }))&#xa;                                    }&#xa;                                    hbox {&#xa;                                        button(action: action(name: &apos;Remove ALL Connectors&apos;, defaultButton: true,&#xa;                                                closure: {&#xa;                                                    removeAllConnectors()&#xa;                                                    connectorsDisplayed = false&#xa;                                                    connectorsframe.dispose()&#xa;                                                }))&#xa;                                        button(action: action(name: &apos;Undo &quot;Remove ALL Connectors&quot;&apos;, defaultButton: true,&#xa;                                                closure: {&#xa;                                                    c.undo()&#xa;                                                    connectorsDisplayed = false&#xa;                                                    connectorsframe.dispose()&#xa;                                                }))&#xa;                                    }&#xa;                                }&#xa;                            }&#xa;                        }&#xa;                    }&#xa;                }&#xa;            }&#xa;        }&#xa;    }&#xa;&#xa;    // prevent some columns in the underlying table model from displaying in the connector candidates UI&#xa;    HideTableColumns(connectorsTable,[&apos;sourceID&apos;])&#xa;&#xa;    // add mouse listener to the connectors manager table&#xa;    connectorsTable.addMouseListener(&#xa;            new MouseAdapter() {&#xa;                // global scope&#xa;                def globalscope=this.this$0&#xa;&#xa;                def chosenconnector=null&#xa;&#xa;                // Take action on mouse click&#xa;                public void mousePressed(MouseEvent event) {&#xa;                    def selectedConnectortablerow=null&#xa;                    def sourcenodetext=&quot;&quot;&#xa;                    def middlelabel=&quot;&quot;&#xa;                    def targetnodetext=&quot;&quot;&#xa;&#xa;                    if ((event.getModifiers() &amp; InputEvent.BUTTON1_MASK) != 0) {&#xa;&#xa;                        // Left Click - select the connector&#xa;&#xa;                        // get the connector data from the selected table entry&#xa;                        selectedConnectortablerow=globalscope.connectors_data[event.getSource().getSelectedRow()]&#xa;                        sourcenodetext=selectedConnectortablerow[&quot;sourcenodetext&quot;]&#xa;                        middlelabel=selectedConnectortablerow[&quot;middlelabel&quot;]&#xa;                        targetnodetext=selectedConnectortablerow[&quot;targetnodetext&quot;]&#xa;&#xa;                        // get the source node of the connector&#xa;                        def sourceNode = getNodeByID(selectedConnectortablerow[&apos;sourceID&apos;])&#xa;&#xa;                        selectedconnectorobject=null&#xa;&#xa;                        //locate connectorOut within the node&#xa;                        sourceNode.connectorsOut.each {&#xa;                            def targetNode = getNodeByID(it.delegate.target.id)&#xa;                            if (targetNode.text.equals(targetnodetext) &amp;&amp;&#xa;                                    sourceNode.text.equals(sourcenodetext) &amp;&amp;&#xa;                                    middlelabel.equals(it.delegate.middleLabel)) {&#xa;                                setAllConnectorsToDefaultColor()&#xa;&#xa;                                // highlight the selected connector in the map to BLUE&#xa;                                it.setColor(Color.BLUE)&#xa;&#xa;                                // save the reference to the connector object&#xa;                                selectedconnectorobject=it&#xa;&#xa;                                // enable connector buttons&#xa;                                globalscope.editconnectorbutton.enabled=true&#xa;                                globalscope.removeconnectorbutton.enabled=true&#xa;                            }&#xa;                        }&#xa;&#xa;                    }&#xa;&#xa;                    // double mouse click&#xa;&#xa;                    else if (event.getClickCount()==2) {&#xa;                        // do nothing&#xa;                    }&#xa;                }&#xa;            }&#xa;    )&#xa;&#xa;    connectorsframe.pack()&#xa;    connectorsframe.show()&#xa;&#xa;}&#xa;&#xa;//**********************************************&#xa;// UI class overrides the connector table cell&#xa;// renderer in the Connectors View&#xa;//**********************************************&#xa;class ConnectorsTableCellRenderer extends JLabel implements TableCellRenderer {&#xa;    public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected,&#xa;                                                   boolean hasFocus, int rowIndex, int vColIndex) {&#xa;&#xa;        // Set up tooltip for cell which shows the note and detail texts related to the node the cell refers to&#xa;        setText(removeHtmlTags(value.toString()))&#xa;&#xa;        // align the text in the cell&#xa;        setHorizontalAlignment(SwingConstants.LEFT)&#xa;&#xa;        if (isSelected)&#xa;        {&#xa;            setBackground(Color.GRAY);&#xa;            setForeground(Color.BLUE);&#xa;        }&#xa;        else&#xa;        {&#xa;            setBackground(table.getBackground());&#xa;            setForeground(table.getForeground());&#xa;        }&#xa;&#xa;        return this&#xa;    }&#xa;}&#xa;&#xa;&#xa;// END OF SCRIPT/**" ID="ID_621368943" CREATED="1389207772225" MODIFIED="1520820687987"/>
</node>
</node>
<node TEXT="zips" POSITION="right" ID="ID_294220045" CREATED="1381771547840" MODIFIED="1385408757698">
<edge COLOR="#007c00"/>
<richcontent TYPE="NOTE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      An add-on may contain any number of nodes containing zip files.
    </p>
    <p>
      
    </p>
    <p>
      &#160;- The immediate child nodes contain a description of the zip. The devtools script releaseAddOn.groovy allows automatic zip creation if the name of this node matches a directory in the current directory.
    </p>
    <p>
      
    </p>
    <p>
      &#160;- The child nodes of these nodes contain the actual zip files.
    </p>
    <p>
      
    </p>
    <p>
      &#160;- Any zip file will be extracted in the &lt;installationbase&gt;. Currently, &lt;installationbase&gt; is always Freeplane's &lt;userhome&gt;, e.g. ~/.freeplane/1.2.
    </p>
    <p>
      
    </p>
    <p>
      &#160;- The files will be processed in the sequence as seen in the map.
    </p>
    <p>
      
    </p>
    <p>
      &#160;- Zip files must be uploaded into the map via the script <i>Tools-&gt;Scripts-&gt;Insert Binary</i>&#160;since they have to be (base64) encoded as simple strings.
    </p>
  </body>
</html>
</richcontent>
</node>
<node TEXT="images" POSITION="right" ID="ID_64645831" CREATED="1381771547856" MODIFIED="1385408757698">
<edge COLOR="#7c007c"/>
<richcontent TYPE="NOTE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      An add-on may define any number of images as child nodes of the images node. The actual image data has to be placed as base64 encoded binary data into the text of a subnode.
    </p>
    <p>
      The images are saved to the <i>${installationbase}/resources/images</i>&#160;directory.
    </p>
    <p>
      
    </p>
    <p>
      The following images should be present:
    </p>
    <ul>
      <li>
        <i>${name}.png</i>, like <i>oldicons-theme.png</i>. This will be used in the app-on details dialog.
      </li>
      <li>
        <i>${name}-icon.png</i>, like <i>oldicons-theme-icon.png</i>. This will be used in the app-on overview.
      </li>
    </ul>
    <p>
      Images can be added automatically by releaseAddOn.groovy or must be uploaded into the map via the script <i>Tools-&gt;Scripts-&gt;Insert Binary</i>&#160;since they have to be (base64) encoded as simple strings.
    </p>
  </body>
</html>
</richcontent>
</node>
<node TEXT="description" FOLDED="true" POSITION="left" ID="ID_1720577024" CREATED="1381756995184" MODIFIED="1485297774595">
<edge COLOR="#ff0000"/>
<richcontent TYPE="NOTE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Description would be awkward to edit as an attribute.
    </p>
    <p>
      So you have to put the add-on description as a child of the <i>'description'</i>&#160;node.
    </p>
  </body>
</html>
</richcontent>
<node TEXT="MapInsight Addon&#xa;&#xa;Introduction&#xa;MapInsight is a Freeplane addon which provides a simple UI for walking around a map and optionally creating connectors This script has been tested on Freeplane 1.3 and 1.5 on Windows and Mac.&#xa;&#xa;A map can get very confusing when there are lots of connectors. This simple UI gives the view from a selected node showing its parent, children and connectors in and out.&#xa;&#xa;Hovering over a node in the UI reveals the notes and details.&#xa;&#xa;Connection Candidates tool finds possible connections through link words, phrases or regular expressions and allows you to create the connector&#xa;Connection Manager shows all connectors in the map in a sortable table with edit/delete options&#xa;&#xa;1. WALKING AROUND NODES&#xa;This addon creates a free standing resizable window that allows you to &apos;walk&apos; around the nodes in a map. When the addon is run the currently selected node in the map is displayed along with its related nodes ie. parent, children, connections in and out.&#xa;The user can double click any of the related nodes and it will be selected and become the currently selected node&#xa;Hovering over any related nodes shows its note and detail text if present.&#xa;To see the Note and details of the currently selected node use the View Menu and select Node Details&#xa;&#xa;To see recent nodes visited see the History menu item&#xa;&#xa;2. FINDING ASSOCIATED NODES&#xa;The addon shows a sortable list of any possible related nodes (candidate nodes) by using &apos;proper&apos; words&#xa;(a) from the selected node&apos;s core text&#xa;(b) optionally from the node&apos;s note text&#xa;(c) optionally from the node&apos;s detail text&#xa;(d) and/or words entered by the user (separated by commas) or you can specify a search phrase which is any string inside double quotes&#xa;(e) and/or a regular expression which is any string inside forward slashes eg /M.*h/ would find the text March, Macbeth. Moth&#xa;For example if the selected node had the word &apos;London&apos; then any other nodes in map with the word &apos;London&apos; in them would show as a possible connections.&#xa;(Proper word means a word is not a noise or stop word such as and, or, if etc. This script has English stop words - can alter by changing &apos;stopWords&apos; table in script)&#xa;If a candidate node is selected it will turn blue.&#xa;Once selected you can view the node in the map without selecting it (locate button) or select the node (Go To button) and Map Insight will &apos;walk&apos; to that node.&#xa;If a candidate node is right clicked then you can choose to add a connector between the main node and the selected candidate node. The connector is created with the middle label being the word that links the main and candidate node (eg &apos;london&apos; in the example above).&#xa;If you wish to automatically create a connector for ALL the candidates then press the &quot;Connect All&quot; button. You can reverse this by clicking the &quot;Undo Connect ALL&quot; button.&#xa;&#xa;3. MANAGING CONNECTORS&#xa;Shows all the connectors in a sortable list and allows you to remove them or change the label if required.&#xa;This is useful when a map has so many connectors that they are difficult to see in the map&#xa;First select the base node to see the connectors belonging to it and its sub nodes. Selecting the root node will view all connectors in the map.&#xa;Choose &apos;Connectors Manager&apos; in the View menu&#xa;All connectors will be shown with the source node, target node and middle label. (To avoid label confusion I decided to just use middle labels).&#xa;Clicking on a connector will highlight the connector in BLUE in the list and BLUE in the map.&#xa;You can remove the connector by clicking the &apos;Remove Connector&apos; button&#xa;You can change the connectors middle label by clicking the &apos;Edit Label&apos;&#xa;&#xa;4. VIEWING CONNECTORS&#xa;The sub menu in the View menu lets you view specific connectors&#xa;&apos;Show Current Node Connectors&apos; will display only connectors to and from the current node in the map. All other connectors will be hidden&#xa;&apos;Show Connectors for a label&apos; will display only connectors with a specific label in the map. All other connectors will be hidden&#xa;&apos;Hide all Connectors&apos; will hide all connectors in the map (useful in crowded maps)&#xa;&apos;Unhide all Connectors&apos; will show all connectors in the map&#xa;&#xa;Version History&#xa;v1.0 First Version See video tutorial for MapInsight v1.0 at https://www.youtube.com/watch?v=cSyhkcsB2-M&#xa;v1.1 Added following new features thanks to forum members feedback&#xa;1 &apos;Refresh current view&apos; in the Actions menu. Updates the current node details which is handy when underlying map has changed&#xa;2 New button &apos;Save As Map&apos; on &apos;Possible Connections&apos; window will save the source node and all suggested nodes together with the connectors into a new map&#xa;3 Connector Candidates Options windows now caters for regular expressions&#xa;4 View, Connectors has new menu item &apos;Show Current Node Connectors&apos; which will display only the connectors for the current node and hide all other connectors. &apos;Unhide All Connectors&apos; will restore view of all connectors&#xa;5 View, Connectors has new menu item &apos;Show Connectors for a label&apos; which will display only the connectors with a middle label that contains the label text and hide all other connectors. &apos;Unhide All Connectors&apos; will restore view of all connectors&#xa;6 Allows multiline labels when adding connectors&#xa;7 Bug fixes (as per https://sourceforge.net/p/freeplane/discussion/758437/thread/a49efba6/)&#xa;This addon is based on V1.1 of the original script" ID="ID_1654392896" CREATED="1513921095257" MODIFIED="1513921166938">
<font BOLD="false"/>
</node>
</node>
<node TEXT="changes" POSITION="left" ID="ID_1266504671" CREATED="1381756995246" MODIFIED="1385408757620">
<edge COLOR="#0000ff"/>
<richcontent TYPE="NOTE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Change log of this add-on: append one node for each noteworthy version and put the details for each version into a child node.
    </p>
  </body>
</html>
</richcontent>
</node>
<node TEXT="license" FOLDED="true" POSITION="left" ID="ID_1476305357" CREATED="1381756995277" MODIFIED="1385408757636">
<edge COLOR="#00ff00"/>
<richcontent TYPE="NOTE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      The add-ons's license that the user has to accept before she can install it.
    </p>
    <p>
      
    </p>
    <p>
      The License text has to be entered as a child of the <i>'license'</i>&#160;node, either as plain text or as HTML.
    </p>
  </body>
</html>
</richcontent>
<node TEXT="&#xa;This add-on is free software: you can redistribute it and/or modify&#xa;it under the terms of the GNU General Public License as published by&#xa;the Free Software Foundation, either version 2 of the License, or&#xa;(at your option) any later version.&#xa;&#xa;This program is distributed in the hope that it will be useful,&#xa;but WITHOUT ANY WARRANTY; without even the implied warranty of&#xa;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&#xa0;&#xa0;See the&#xa;GNU General Public License for more details.&#xa;" ID="ID_99261528" CREATED="1381756995308" MODIFIED="1381756995308"/>
</node>
<node TEXT="preferences.xml" POSITION="left" ID="ID_1169408938" CREATED="1381756995418" MODIFIED="1385408757636">
<edge COLOR="#ff00ff"/>
<richcontent TYPE="NOTE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      <font face="SansSerif, sans-serif" color="#000000">The child node contains the add-on configuration as an extension to mindmapmodemenu.xml (in Tools-&gt;Preferences-&gt;Add-ons). </font>
    </p>
    <p>
      <font face="SansSerif, sans-serif" color="#000000">Every property in the configuration should receive a default value in <i>default.properties</i>&#160;node.</font>
    </p>
  </body>
</html>
</richcontent>
</node>
<node TEXT="default.properties" POSITION="left" ID="ID_1434342109" CREATED="1381006378455" MODIFIED="1484696895512">
<edge COLOR="#00ffff"/>
<richcontent TYPE="NOTE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      These properties play together with the preferences: Each property defined in the preferences should have a default value in the attributes of this node.
    </p>
  </body>
</html>
</richcontent>
<attribute_layout NAME_WIDTH="181.7999913311009 pt" VALUE_WIDTH="271.79998703956664 pt"/>
</node>
<node TEXT="translations" FOLDED="true" POSITION="left" ID="ID_1618020204" CREATED="1381756995527" MODIFIED="1484696694296" HGAP_QUANTITY="19.399999742507948 pt" VSHIFT_QUANTITY="54.89999738216413 pt">
<edge COLOR="#ffff00"/>
<richcontent TYPE="NOTE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      The translation keys that this script uses. Define one child node per supported locale. The attributes contain the translations. Define at least 'addons.${name}' for the add-on's name.
    </p>
  </body>
</html>
</richcontent>
<node TEXT="en" ID="ID_37110248" CREATED="1484684633238" MODIFIED="1484696682655" HGAP_QUANTITY="14.899999957084658 pt" VSHIFT_QUANTITY="72.89999652385728 pt">
<attribute NAME="addons.${name}" VALUE="MapInsight"/>
</node>
</node>
<node POSITION="right" ID="ID_248608830" CREATED="1379964830451" MODIFIED="1520820787927"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      <b>Location menu:</b>&#160;File<i>&#160;&gt; View &gt; MapInsight</i>
    </p>
  </body>
</html>

</richcontent>
<edge COLOR="#0000ff"/>
</node>
<node TEXT="deinstall" POSITION="right" ID="ID_18388134" CREATED="1484684633271" MODIFIED="1485298692206" HGAP_QUANTITY="-501.69997540950897 pt" VSHIFT_QUANTITY="39.599998111724915 pt">
<edge COLOR="#808080"/>
<richcontent TYPE="NOTE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      List of files and/or directories to remove on uninstall
    </p>
  </body>
</html>
</richcontent>
<attribute NAME="delete" VALUE="${installationbase}/addons/${name}.script.xml"/>
</node>
</node>
</map>
